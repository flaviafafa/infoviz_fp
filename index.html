<html>

<head>
    <meta charset="UTF-8">

    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script
        src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.min.js"></script>
    <link rel="stylesheet"
        href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        body {
            margin: 0px;
            font-family: 'Baloo 2', cursive;
            color: #041F3D;
            display: flex;
            flex-direction: column;
        }

        .container-centered {
            width: 96%;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
        }

        h2 {
            font-size: 28px;
            font-weight: 700;
            color: #FF5800;
            margin-top: 40px;
            margin-bottom: 60px;
        }

        .colored-bg {
            background-color: #ffefda
        }

        .session {
            padding-top: 40px;
            padding-bottom: 40px;
        }

        .map-container {
  display: flex;
  flex-direction: row;
  width: 70%;
  height: 70vh;
  margin: 0 auto;
  box-sizing: border-box;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  position: relative;
}

#mapCanvas {
  flex: 1;
  height: 100%;
}

.sidebar {
  width: 250px;
  background-color: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  padding: 12px 16px;
  overflow-y: auto;
  z-index: 2;
}

#geocoder-container {
  position: absolute;
  top: 10px;
  left: 20px;
  width: 50%;
  z-index: 3;
}



        #image-button-grid {
            margin-top: auto;
        }




        .discrete-legend {
            margin: 8px 0 16px 0;
        }

        .legend-bar {
            display: flex;
            height: 14px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
            box-shadow: inset 0 0 0 1px #ccc;
        }

        .legend-step {
            flex: 1;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #041F3D;
            padding: 0 2px;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .image-grid button {
            border: none;
            background: none;
            padding: 0;
            cursor: pointer;
        }

        .image-grid img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .image-grid img:hover {
            transform: scale(1.05);
        }
    </style>


</head>

<body>

    <!--Introduction-->
    <div class="session container-centered">
        <div>
            <img src="images/Bite.png" alt="Dog Bite Sequence" width="600"
                style="margin-top: -40px; margin-bottom: -40px;">
            <h1 style="font-weight:800; font-size: 36px;">
                Bitten by the Numbers: A Data Story on NYC Dogs
            </h1>
            <h3>Flavia Jiang, Curtis Xu, Xinyi Zhou</h3>

            <div>Intro paragraph</div>
        </div>
    </div>

    <!--Bite incidents by breed-->
    <div class="session colored-bg">
        <div id="container-breed" class="container-centered">
            <h2>1. Are These Breeds Friendlier (or Bite-ier) Than You Expected?</h2>
            <svg id="svg-breed" height="490" width="960"></svg>
        </div>
    </div>

    <!--Bite incidents by gender x spay & neuter-->
    <div class="session">
        <div id="container-gender" class="container-centered">
            <h2>2. Spaying or Neutering Makes Dogs Over 2x Less Likely to Bite</h2>
            <svg id="svg-gender" height="350" width="560"></svg>
        </div>
    </div>

    <!--Bite incidents by age-->
    <div class="session colored-bg">
        <div id="container-age" class="colored-bg container-centered">
            <h2>3. Growing Up Means Biting Less—for Dogs, Too</h2>
            <svg id="svg-age" height="520" width="580"></svg>
        </div>
    </div>

    <!--Bite incidents by time-->
    <div class="session">
        <div id="container-time" class="container-centered">
            <h2>4. Do Dog Bites Spike in Summer—Right Alongside Ice Cream Sales?</h2>
            <div style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 50px">
                <svg id="svg-time" height="450" width="650"></svg>
                <div style="display:flex; flex-direction:column">
                    <svg id="svg-temp" height="300" width="450"></svg>
                    <svg id="svg-precip" height="300" width="450"></svg>
                </div>

            </div>

        </div>
    </div>

    <!--Bite incidents by neighborhood-->
    <div class="session colored-bg">
        <div id="container-zip" class="colored-bg container-centered">
            <h2>5. Explore Where NYC's Dog Bites Happen—and Why</h2>
        </div>

        <div class="map-container">
            <div id="mapCanvas"></div>
            <div id="layer-control" class="sidebar">
              <div id="layer-buttons"></div>
              <h4 style="margin-bottom: 8px; text-align: center; font-size: 14px; font-weight: bold; color: #041F3D;">
                Tap a dog to discover its top territory for bites
              </h4>
              
              <div id="image-button-grid" class="image-grid"></div>
            </div>
            <div id="geocoder-container"></div>
          </div>
          

    </div>



    <script>
        const requestData = async () => {

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Chart 1: Bite incidents by breed
            const breedData = await d3.csv("breed_df.csv");

            breedData.forEach(d => {
                d.bite_score = 16 - +d.bite_score_ranking;
                d.aggresiveness_score = 16 - +d.aggresiveness_score_ranking;
            });

            // Default for toggle
            let currentSort = "bite";

            const svg_breed = d3.select("#svg-breed");
            const width_breed = +svg_breed.attr("width");
            const height_breed = +svg_breed.attr("height");
            const margin_breed = { top: 90, right: 20, bottom: 60, left: 40 };
            const chartWidth_breed = width_breed - margin_breed.left - margin_breed.right;
            const chartHeight_breed = height_breed - margin_breed.top - margin_breed.bottom;

            const g_breed = svg_breed.append("g")
                .attr("transform", `translate(${margin_breed.left},${margin_breed.top})`);

            // Update chart based on current sort
            function updateChart() {
                const sortedData = [...breedData].sort((a, b) =>
                    currentSort === "bite" ?
                        d3.descending(+a.bite_score, +b.bite_score) :
                        d3.descending(+a.aggresiveness_score, +b.aggresiveness_score)
                );

                xScale_breed.domain(sortedData.map(d => d.breed));

                // Transition for bars and images
                const t = svg_breed.transition().duration(750);

                g_breed.selectAll(".breed-group")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("transform", d => `translate(${xScale_breed(d.breed)},0)`);

                g_breed.selectAll(".bar-bite")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("y", d => yScale_breed(d.bite_score))
                    .attr("height", d => chartHeight_breed / 2 - yScale_breed(d.bite_score));

                g_breed.selectAll(".bar-agg")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("height", d => yScale_breed_neg(d.aggresiveness_score));

                g_breed.selectAll(".breed-image")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("cx", xScale_breed.bandwidth() / 2);

                g_breed.selectAll(".breed-img")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("x", -xScale_breed.bandwidth() * 0.2);

                updateSortToggle();
            }

            // Create or update the sort toggle button
            function updateSortToggle() {
                g_breed.selectAll(".sort-toggle").remove();

                const toggle = g_breed.append("g")
                    .attr("class", "sort-toggle")
                    .attr("transform", `translate(${chartWidth_breed / 2 - 250}, -85)`);

                // Add toggle background
                toggle.append("rect")
                    .attr("width", 500)
                    .attr("height", 45)
                    .attr("rx", 20)
                    .attr("ry", 20)
                    .attr("fill", "white")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                // Add label
                toggle.append("text")
                    .attr("x", 60)
                    .attr("y", 27.5)
                    .attr("text-anchor", "middle")
                    .text("Sort By:")
                    .style("fill", "#FF5800")
                    .style("font-size", "18px")
                    .style("font-weight", "bold");

                // Add two options
                toggle.append("text")
                    .attr("x", 170)
                    .attr("y", 27.5)
                    .attr("text-anchor", "middle")
                    .text("Bite Frequency")
                    .style("fill", "#041F3D")
                    .style("font-size", "18px")
                    .style("font-weight", currentSort === "bite" ? "bold" : "normal")
                    .style("cursor", "pointer")
                    .on("mouseover", function () {
                        d3.select(this).style("cursor", "pointer");
                    })
                    .on("click", () => {
                        if (currentSort !== "bite") {
                            currentSort = "bite";
                            updateChart();
                        }
                    });

                toggle.append("text")
                    .attr("x", 360)
                    .attr("y", 27.5)
                    .attr("text-anchor", "middle")
                    .text("Owner-Rated Aggressiveness")
                    .style("fill", "#041F3D")
                    .style("font-size", "18px")
                    .style("font-weight", currentSort === "agg" ? "bold" : "normal")
                    .style("cursor", "pointer")
                    .on("mouseover", function () {
                        d3.select(this).style("cursor", "pointer");
                    })
                    .on("click", () => {
                        if (currentSort !== "agg") {
                            currentSort = "agg";
                            updateChart();
                        }
                    });
            }

            // Create the initial chart
            g_breed.append("line")
                .attr("x1", 0)
                .attr("y1", chartHeight_breed / 2)
                .attr("x2", chartWidth_breed)
                .attr("y2", chartHeight_breed / 2)
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .lower();

            const xScale_breed = d3.scaleBand()
                .domain(breedData.map(d => d.breed))
                .range([0, chartWidth_breed])
                .padding(0.4);

            const yScale_breed = d3.scaleLinear()
                .domain([0, 15])
                .range([chartHeight_breed / 2, 0]);

            const yScale_breed_neg = d3.scaleLinear()
                .domain([0, 15])
                .range([0, chartHeight_breed / 2]);

            // Add y-axis titles
            g_breed.append("text")
                .attr("y", 5)
                .attr("x", chartWidth_breed / 2)
                .attr("text-anchor", "middle")
                .text("Bite Frequency")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            g_breed.append("text")
                .attr("y", chartHeight_breed - margin_breed.bottom + 70)
                .attr("x", chartWidth_breed / 2)
                .attr("text-anchor", "middle")
                .text("Owner-Rated Aggressiveness")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Create a group for each breed 
            const breedGroups = g_breed.selectAll(".breed-group")
                .data(breedData)
                .join("g")
                .attr("class", "breed-group")
                .attr("transform", d => `translate(${xScale_breed(d.breed)},0)`);

            // Add bars
            breedGroups.append("rect")
                .attr("class", "bar-bite")
                .attr("width", xScale_breed.bandwidth())
                .attr("y", d => yScale_breed(d.bite_score))
                .attr("height", d => chartHeight_breed / 2 - yScale_breed(d.bite_score))
                .attr("fill", "#ff8c42")
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("opacity", 0.8);

            breedGroups.append("rect")
                .attr("class", "bar-agg")
                .attr("width", xScale_breed.bandwidth())
                .attr("y", chartHeight_breed / 2)
                .attr("height", d => yScale_breed_neg(d.aggresiveness_score))
                .attr("fill", "#3ec9c1")
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("opacity", 0.8);

            // Add image circles
            breedGroups.append("circle")
                .attr("class", "breed-image")
                .attr("cx", xScale_breed.bandwidth() / 2)
                .attr("cy", chartHeight_breed / 2)
                .attr("r", xScale_breed.bandwidth() * 0.75)
                .attr("fill", "white")
                .attr("stroke", "#041f3d")
                .attr("stroke-width", 2);

            // Add images
            breedGroups.append("image")
                .attr("class", "breed-img")
                .attr("xlink:href", d => `images/${d.breed.replaceAll(' ', '_')}.png`)
                .attr("x", -xScale_breed.bandwidth() * 0.2)
                .attr("y", chartHeight_breed / 2 - xScale_breed.bandwidth() * 0.65)
                .attr("width", xScale_breed.bandwidth() * 1.4)
                .attr("height", xScale_breed.bandwidth() * 1.4);

            // Create tooltip
            const tooltip = g_breed.append("g")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            tooltip.append("rect")
                .attr("width", 440)
                .attr("height", 130)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 3);

            tooltip.append("image")
                .attr("class", "tooltip-img")
                .attr("x", 12)
                .attr("y", 10)
                .attr("width", 110)
                .attr("height", 110);

            tooltip.append("text")
                .attr("class", "tooltip-title")
                .attr("x", 130)
                .attr("y", 40)
                .style("font-size", "18px")
                .style("font-weight", "bold");

            tooltip.append("text")
                .attr("class", "tooltip-bite")
                .attr("x", 130)
                .attr("y", 70)
                .style("font-size", "16px");

            tooltip.append("text")
                .attr("class", "tooltip-agg")
                .attr("x", 130)
                .attr("y", 100)
                .style("font-size", "16px");

            // Hover-over functions
            breedGroups.on("mouseover", function (event, d) {
                d3.select(this).selectAll("rect")
                    .attr("opacity", 1)
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                // Dim other breeds
                breedGroups.filter(dd => dd !== d).selectAll("rect")
                    .attr("opacity", 0.3);

                const [mouseX, mouseY] = d3.pointer(event, svg_breed.node());
                const tooltipWidth = 440;
                const tooltipHeight = 130;
                const padding = 5;
                const barPadding = 20;

                let x;
                if (mouseX > width_breed - tooltipWidth - padding) {
                    // Tooltip will appear to the left
                    x = mouseX - tooltipWidth - barPadding - 50;
                } else {
                    // Tooltip will appear to the right
                    x = mouseX + padding - 20;
                }

                let y;
                if (mouseY < chartHeight_breed / 2 - 100) {
                    y = mouseY + padding;
                } else {
                    y = mouseY - tooltipHeight - padding;
                }

                // Boundary checks
                x = Math.max(padding, Math.min(x, width_breed - tooltipWidth - padding));
                y = Math.max(padding, Math.min(y, height_breed - tooltipHeight - padding));

                tooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);

                tooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);

                tooltip.select(".tooltip-img")
                    .attr("xlink:href", `images/${d.breed.replaceAll(' ', '_')}.png`);

                tooltip.select(".tooltip-title")
                    .text(d.breed);

                tooltip.select(".tooltip-bite")
                    .html(`Bite Frequency: <tspan style="font-weight:bold">${d.bite_score} out of 15</tspan>`);

                tooltip.select(".tooltip-agg")
                    .html(`Owner-Rated Aggressiveness: <tspan style="font-weight:bold">${d.aggresiveness_score} out of 15</tspan>`);
            })
                .on("mousemove", function (event) {
                    const [mouseX, mouseY] = d3.pointer(event, svg_breed.node());
                    const tooltipWidth = 440;
                    const tooltipHeight = 130;
                    const padding = 15;
                    const barPadding = 20;

                    let x;
                    if (mouseX > width_breed - tooltipWidth - padding) {
                        x = mouseX - tooltipWidth - barPadding - 50;
                    } else {
                        x = mouseX + padding - 20;
                    }

                    let y;
                    if (mouseY < chartHeight_breed / 2 - 100) {
                        y = mouseY + padding;
                    } else {
                        y = mouseY - tooltipHeight - padding;
                    }

                    x = Math.max(padding, Math.min(x, width_breed - tooltipWidth - padding));
                    y = Math.max(padding, Math.min(y, height_breed - tooltipHeight - padding));

                    tooltip.attr("transform", `translate(${x},${y})`);
                })
                .on("mouseout", function () {
                    breedGroups.selectAll("rect")
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");

                    tooltip.style("opacity", 0);
                });

            // Create axes
            const yAxis_breed = d3.axisLeft(yScale_breed)
                .tickValues([0, 3, 6, 9, 12, 15])
                .tickSizeOuter(0);

            g_breed.append("g")
                .attr("class", "y-axis")
                .call(yAxis_breed)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text").style("font-size", "14px").style("fill", "#041F3D").attr("dx", "-0.2em"));

            const yAxis_breed_neg = d3.axisLeft(yScale_breed_neg)
                .tickValues([0, 3, 6, 9, 12, 15])
                .tickSizeOuter(0);

            g_breed.append("g")
                .attr("transform", `translate(0,${chartHeight_breed / 2})`)
                .attr("class", "y-axis")
                .call(yAxis_breed_neg)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text").style("font-size", "14px").style("fill", "#041F3D").attr("dx", "-0.2em"));

            // Initialize the toggle
            updateSortToggle();

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Part 2: Bite incidents by gender x spay & neuter
            const genderData = await d3.csv("gender_spay_df.csv");

            genderData.forEach(d => {
                d.spayed_or_neutered = d.spayed_or_neutered === "True";
                d.bite_versus_population_ratio = +d.bite_versus_population_ratio;
            });

            const svg_gender = d3.select("#svg-gender");
            const width_gender = +svg_gender.attr("width");
            const height_gender = +svg_gender.attr("height");
            const margin_gender = { top: 40, right: 150, bottom: 80, left: 80 };
            const chartWidth_gender = width_gender - margin_gender.left - margin_gender.right;
            const chartHeight_gender = height_gender - margin_gender.top - margin_gender.bottom;

            const g_gender = svg_gender.append("g")
                .attr("transform", `translate(${margin_gender.left},${margin_gender.top})`);

            // Set up scales
            const maxValue = d3.max(genderData, d => d.bite_versus_population_ratio);
            const xScale_gender = d3.scaleLinear()
                .domain([0, maxValue * 1.1])
                .range([0, chartWidth_gender]);

            const yScale_gender = d3.scaleBand()
                .domain(["F", "M"])
                .range([0, chartHeight_gender])
                .padding(0.5);

            // Add vertical line at x=1 (average)
            const bg_gender = g_gender.append("g")
                .attr("class", "background-group");

            bg_gender.append("line")
                .attr("x1", xScale_gender(1))
                .attr("y1", 0)
                .attr("x2", xScale_gender(1))
                .attr("y2", chartHeight_gender)
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");

            bg_gender.append("text")
                .attr("x", xScale_gender(1) + 5)
                .attr("y", 20)
                .text("1 (average)")
                .style("font-size", "16px")
                .style("fill", "#041F3D");

            // Create lollipops
            const fg_gender = g_gender.append("g")
                .attr("class", "foreground-group");

            genderData.sort((a, b) => b.bite_versus_population_ratio - a.bite_versus_population_ratio);

            const genderGroups = fg_gender.selectAll(".gender-group")
                .data(genderData)
                .enter()
                .append("g")
                .attr("class", "gender-group");

            genderGroups.each(function (d) {
                const group = d3.select(this);
                const circleX = xScale_gender(d.bite_versus_population_ratio);
                const circleY = yScale_gender(d.gender) + yScale_gender.bandwidth() / 2;

                group.append("line")
                    .attr("x1", 0)
                    .attr("y1", circleY)
                    .attr("x2", circleX)
                    .attr("y2", circleY)
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                group.append("circle")
                    .attr("cx", circleX)
                    .attr("cy", circleY)
                    .attr("r", 16)
                    .attr("fill", d.spayed_or_neutered ? "#3ec9c1" : "#ff8c42")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2)
                    .attr("class", "gender-circle");

                group.append("text")
                    .attr("x", circleX)
                    .attr("y", circleY)
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .text(d3.format(".1f")(d.bite_versus_population_ratio))
                    .style("font-size", "16px")
                    .style("fill", "#041F3D")
                    .style("font-weight", "bold")
                    .style("pointer-events", "none");
            });

            // Add y-axis
            const yAxis_gender = d3.axisLeft(yScale_gender)
                .tickFormat(d => d === "F" ? "Female" : "Male")
                .tickSize(0)
                .tickPadding(7);

            g_gender.append("g")
                .call(yAxis_gender)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text")
                    .style("font-size", "16px")
                    .style("fill", "#041F3D")
                    .style("font-weight", "bold"));

            // Add x-axis
            const xAxis_gender = d3.axisBottom(xScale_gender).ticks(5);

            g_gender.append("g")
                .attr("transform", `translate(0,${chartHeight_gender})`)
                .call(xAxis_gender)
                .call(g => g.select(".domain")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text")
                    .style("font-size", "14px")
                    .style("fill", "#041F3D"));

            g_gender.append("text")
                .attr("x", chartWidth_gender / 2)
                .attr("y", chartHeight_gender + 60)
                .attr("text-anchor", "middle")
                .text("Bite Frequency Score")
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Add legend
            const legend = g_gender.append("g")
                .attr("transform", `translate(${chartWidth_gender - 100}, 20)`);

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 10)
                .attr("r", 10)
                .attr("fill", "#3ec9c1")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 1.5);

            legend.append("text")
                .attr("x", 25)
                .attr("y", 15)
                .text("Spayed/Neutered")
                .style("font-size", "16px")
                .style("fill", "#041F3D");

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 40)
                .attr("r", 10)
                .attr("fill", "#ff8c42")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 1.5);

            legend.append("text")
                .attr("x", 25)
                .attr("y", 45)
                .text("NOT Spayed/Neutered")
                .style("font-size", "16px")
                .style("fill", "#041F3D");

            // Create tooltip
            const genderTooltip = g_gender.append("g")
                .attr("class", "gender-tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            genderTooltip.append("rect")
                .attr("width", 300)
                .attr("height", 80)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke-width", 4);

            genderTooltip.append("text")
                .attr("class", "tooltip-interpretation")
                .attr("x", 15)
                .attr("y", 30)
                .attr("fill", "#041F3D")
                .style("font-size", "16px")
                .style("font-family", "'Baloo 2', cursive");

            // Hover-over events
            genderGroups.on("mouseover", function (event, d) {
                const borderColor = d.spayed_or_neutered ? "#3ec9c1" : "#ff8c42";
                d3.select(this).select(".gender-circle")
                    .attr("r", 20)
                    .attr("stroke-width", 3);

                genderTooltip.select("rect")
                    .attr("stroke", borderColor);

                const ratio = d.bite_versus_population_ratio.toFixed(2);
                const comparison = d.bite_versus_population_ratio > 1 ? "higher" : "lower";
                const gender = d.gender === "F" ? "Female" : "Male";
                const status = d.spayed_or_neutered ? "spayed/neutered" : "NOT spayed/neutered";

                const htmlContent = `<tspan style="font-weight:bold">${gender}</tspan> dogs that are <tspan style="font-weight:bold">${status}</tspan> have a bite rate <tspan style="font-weight:bold">${ratio}</tspan> times <tspan style="font-weight:bold">${comparison}</tspan> than expected.`;

                // Text wrapping
                const tooltipText = genderTooltip.select(".tooltip-interpretation");
                tooltipText.selectAll("*").remove();

                const maxCharsPerLine = 35;
                const words = htmlContent.split(' ');
                let line = [];
                let lineNumber = 0;
                const xPos = 15;
                const initialYPos = 30;
                const lineHeight = 20;

                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontFamily = "'Baloo 2', cursive";
                tempDiv.style.fontSize = '16px';
                document.body.appendChild(tempDiv);

                words.forEach((word, i) => {
                    line.push(word);
                    tempDiv.innerHTML = line.join(' ');
                    const testWidth = tempDiv.offsetWidth;

                    if (testWidth > 280 && line.length > 1) {
                        line.pop();
                        tooltipText.append("tspan")
                            .attr("x", xPos)
                            .attr("y", initialYPos + (lineNumber * lineHeight))
                            .html(line.join(' '));

                        line = [word];
                        lineNumber++;
                    }
                });

                // Add the last line
                if (line.length > 0) {
                    tooltipText.append("tspan")
                        .attr("x", xPos)
                        .attr("y", initialYPos + (lineNumber * lineHeight))
                        .html(line.join(' '));
                }

                document.body.removeChild(tempDiv);

                const tooltipHeight = 50 + (lineNumber * lineHeight);
                genderTooltip.select("rect")
                    .attr("height", tooltipHeight);

                // Position tooltip
                const [mouseX, mouseY] = d3.pointer(event, svg_gender.node());
                const tooltipWidth = 300;
                const padding = 10;
                const pointerOffset = 15;

                let x = mouseX + tooltipWidth + padding > width_gender
                    ? mouseX - tooltipWidth - pointerOffset
                    : mouseX + pointerOffset;

                let y = mouseY - (tooltipHeight / 2);
                y = Math.max(padding, Math.min(y, height_gender - tooltipHeight - padding));

                genderTooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);
            })
                .on("mouseout", function () {
                    d3.select(this).select(".gender-circle")
                        .attr("r", 16)
                        .attr("stroke-width", 2);

                    genderTooltip.style("opacity", 0);
                })
                .on("mousemove", function (event) {
                    let [mouseX, mouseY] = d3.pointer(event, svg_gender.node());
                    mouseX = mouseX - 60;
                    const tooltipWidth = 300;
                    const tooltipHeight = +genderTooltip.select("rect").attr("height");
                    const padding = 10;
                    const pointerOffset = 15;

                    let x = mouseX + tooltipWidth + padding > width_gender
                        ? mouseX - tooltipWidth - pointerOffset
                        : mouseX + pointerOffset;

                    let y = mouseY - (tooltipHeight / 2);
                    y = Math.max(padding, Math.min(y, height_gender - tooltipHeight - padding));

                    genderTooltip.attr("transform", `translate(${x},${y})`);
                });


            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Chart 3: Bite incidents by age
            const ageData = await d3.csv("age_df.csv");

            const svg_age = d3.select("#svg-age");

            const width_age = +svg_age.attr("width");
            const height_age = +svg_age.attr("height");
            const margin_age = { top: 50, right: 90, bottom: 130, left: 10 };
            const chartWidth_age = width_age - margin_age.left - margin_age.right;
            const chartHeight_age = height_age - margin_age.top - margin_age.bottom;

            const g_age = svg_age.append("g")
                .attr("transform", `translate(${margin_age.left},${margin_age.top})`);

            ageData.forEach(d => {
                d.age = +d.age;
                d.bite_versus_population_ratio = +d.bite_versus_population_ratio;
                d.ageLabel = d.age === 1 ? "≤1" : d.age.toString();
            });

            // Set up scales
            const xScale_age = d3.scaleBand()
                .domain(ageData.map(d => d.ageLabel))
                .range([0, chartWidth_age])
                .padding(0.3);

            const maxRatio = d3.max(ageData, d => d.bite_versus_population_ratio);
            const yScale_age = d3.scaleLinear()
                .domain([0, maxRatio * 1.1])
                .range([chartHeight_age, 0]);

            // Add horizontal line at y=1
            g_age.append("line")
                .attr("x1", 0)
                .attr("y1", yScale_age(1))
                .attr("x2", chartWidth_age)
                .attr("y2", yScale_age(1))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");

            g_age.append("text")
                .attr("x", chartWidth_age - 10)
                .attr("y", yScale_age(1) - 12)
                .attr("text-anchor", "end")
                .text("1 (average)")
                .style("font-size", "18px")
                .style("fill", "#041F3D");

            // Add lollipops
            const colorScale = d3.scaleThreshold()
                .domain([0.8, 1.6])
                .range(["#ffd1a8", "#ff8c42", "#e65c00"]);

            const lollipopGroups = g_age.selectAll(".lollipop-group")
                .data(ageData)
                .join("g")
                .attr("class", "lollipop-group")
                .attr("transform", d => `translate(${xScale_age(d.ageLabel) + xScale_age.bandwidth() / 2},0)`);

            lollipopGroups.append("line")
                .attr("class", "lollipop-line")
                .attr("y1", yScale_age(0))
                .attr("y2", d => yScale_age(d.bite_versus_population_ratio))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            lollipopGroups.append("circle")
                .attr("class", "lollipop-circle")
                .attr("cy", d => yScale_age(d.bite_versus_population_ratio))
                .attr("r", 10)
                .attr("fill", d => colorScale(d.bite_versus_population_ratio))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            // x axis
            const xAxis = g_age.append("g")
                .attr("transform", `translate(0,${chartHeight_age})`)
                .call(d3.axisBottom(xScale_age));

            xAxis.selectAll("text")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#041F3D")
                .attr("dy", "1em");

            xAxis.append("text")
                .attr("x", chartWidth_age / 2)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Age")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D")
                .style("font-family", "'Baloo 2', cursive");

            xAxis.select(".domain")
                .attr("stroke-width", 2);

            xAxis.selectAll(".tick line")
                .attr("stroke-width", 2);

            // y axis
            const yAxis = g_age.append("g")
                .attr("transform", `translate(${chartWidth_age},0)`)
                .call(d3.axisRight(yScale_age).ticks(5));

            yAxis.select(".domain")
                .attr("stroke-width", 2);

            yAxis.selectAll(".tick line")
                .attr("stroke-width", 2);

            yAxis.selectAll("text")
                .style("font-size", "14px")
                .style("fill", "#041F3D")
                .attr("dx", "0.3em");

            g_age.append("text")
                .attr("y", -20)
                .attr("x", chartWidth_age - 60)
                .attr("text-anchor", "middle")
                .text("Bite Frequency Score")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Tooltip
            const ageTooltip = g_age.append("g")
                .attr("class", "age-tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            ageTooltip.append("rect")
                .attr("width", 350)
                .attr("height", 95)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke-width", 4);

            ageTooltip.append("text")
                .attr("class", "tooltip-interpretation")
                .attr("x", 15)
                .attr("y", 40)
                .attr("fill", "#041F3D")
                .style("font-size", "18px")
                .style("font-family", "'Baloo 2', cursive");

            // Hover-over events
            lollipopGroups.on("mouseover", function (event, d) {
                const borderColor = colorScale(d.bite_versus_population_ratio);
                d3.select(this).select(".lollipop-circle")
                    .attr("r", 15)
                    .attr("stroke-width", 4);

                d3.select(this).select(".lollipop-line")
                    .attr("stroke-width", 4);

                ageTooltip.select("rect")
                    .attr("stroke", borderColor);

                const ratio = d.bite_versus_population_ratio.toFixed(2);
                const comparison = d.bite_versus_population_ratio > 1 ? "higher" : "lower";

                const htmlContent = `At the age of <tspan style="font-weight:bold">${d.age === 1 ? "1 year or younger" : `${d.age} years`}</tspan>, the bite rate is <tspan style="font-weight:bold">${ratio}</tspan> times <tspan style="font-weight:bold">${comparison}</tspan> than expected based on population share.`;

                // text wrapping
                const tooltipText = ageTooltip.select(".tooltip-interpretation");
                tooltipText.selectAll("*").remove();

                const maxCharsPerLine = 40;
                const words = htmlContent.split(' ');
                let line = [];
                let lineNumber = 0;
                const xPos = 15;
                const initialYPos = 30;
                const lineHeight = 23;

                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontFamily = "'Baloo 2', cursive";
                tempDiv.style.fontSize = '18px';
                document.body.appendChild(tempDiv);

                words.forEach((word, i) => {
                    line.push(word);
                    tempDiv.innerHTML = line.join(' ');
                    const testWidth = tempDiv.offsetWidth;

                    if (testWidth > 340 && line.length > 1) {
                        line.pop();
                        tooltipText.append("tspan")
                            .attr("x", xPos)
                            .attr("y", initialYPos + (lineNumber * lineHeight))
                            .html(line.join(' '));

                        line = [word];
                        lineNumber++;
                    }
                });

                // Add the last line
                if (line.length > 0) {
                    tooltipText.append("tspan")
                        .attr("x", xPos)
                        .attr("y", initialYPos + (lineNumber * lineHeight))
                        .html(line.join(' '));
                }

                document.body.removeChild(tempDiv);

                const [mouseX, mouseY] = d3.pointer(event, svg_age.node());
                const tooltipWidth = 350;
                const tooltipHeight = +ageTooltip.select("rect").attr("height");
                const padding = 10;

                let x = mouseX + tooltipWidth + padding > width_age
                    ? Math.max(padding, mouseX - tooltipWidth - padding)
                    : Math.max(padding, mouseX + padding);

                let y = mouseY + tooltipHeight + padding > height_age
                    ? Math.max(padding, mouseY - tooltipHeight - padding)
                    : Math.max(padding, mouseY + padding);

                y = Math.max(padding, y);

                ageTooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y - 40})`);
            })
                .on("mouseout", function () {
                    d3.select(this).select(".lollipop-circle")
                        .attr("r", 10)
                        .attr("stroke-width", 2);

                    d3.select(this).select(".lollipop-line")
                        .attr("stroke-width", 2);

                    ageTooltip.style("opacity", 0);
                })
                .on("mousemove", function (event) {
                    const [mouseX, mouseY] = d3.pointer(event, svg_age.node());
                    const tooltipWidth = 350;
                    const tooltipHeight = +ageTooltip.select("rect").attr("height");
                    const padding = 10;

                    let x = mouseX + tooltipWidth + padding > width_age
                        ? Math.max(padding, mouseX - tooltipWidth - padding)
                        : Math.max(padding, mouseX + padding);

                    let y = mouseY + tooltipHeight + padding > height_age
                        ? Math.max(padding, mouseY - tooltipHeight - padding)
                        : Math.max(padding, mouseY + padding);

                    ageTooltip.attr("transform", `translate(${x},${y - 40})`);
                })

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------


            // Chart 4: Bite incidents by time
            const timeData = await d3.csv("time_df.csv");
            console.log(timeData);

            const monthlyTotals = {};

            timeData.forEach(d => {
                const key = `${String(d.month).padStart(2, '0')}-${d.year}`;
                const bites = +d.number_of_bites;
                const temp = +d.temperature_avg;
                const precip = +d.precipitation;

                if (!monthlyTotals[key]) {
                    monthlyTotals[key] = {
                        monthYear: key,
                        year: +d.year,
                        month: +d.month,
                        totalBites: 0,
                        tempSum: 0,
                        precipitation: 0,
                        dayCount: 0
                    };
                }
                monthlyTotals[key].totalBites += bites;
                monthlyTotals[key].tempSum += temp;
                monthlyTotals[key].dayCount += 1;
                monthlyTotals[key].precipitation += precip;
            });

            const monthlyData = Object.values(monthlyTotals).map(d => {
                return {
                    monthYear: d.monthYear,
                    year: d.year,
                    month: d.month,
                    totalBites: d.totalBites,
                    avgTemp: d.tempSum / d.dayCount,
                    avgPrecip: d.precipitation / d.dayCount,
                };
            }).sort((a, b) => a.year - b.year || a.month - b.month);

            console.log(monthlyData);

            // ---------- TIME CHART ----------
            const svg_time = d3.select("#svg-time");
            const width_time = +svg_time.attr("width");
            const height_time = +svg_time.attr("height");
            const margin_time = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_time = width_time - margin_time.left - margin_time.right;
            const chartHeight_time = height_time - margin_time.top - margin_time.bottom;

            const g_time = svg_time.append("g")
                .attr("transform", `translate(${margin_time.left},${margin_time.top})`);

            const xScale_time = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_time]);

            const yScale_time = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.totalBites))
                .range([chartHeight_time, 0]);

            const time_bite_line = d3.line()
                .x((d, i) => xScale_time(i))
                .y(d => yScale_time(d.totalBites));

            g_time.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "#FD8C40")
                .attr("stroke-width", 2)
                .attr("d", time_bite_line);

            const xAxis_time = d3.axisBottom(xScale_time)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

            g_time.append("g")
                .attr("transform", `translate(0,${chartHeight_time})`)
                .call(xAxis_time)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            const yAxis_time = d3.axisLeft(yScale_time);
            g_time.append("g").call(yAxis_time);

            svg_time.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_time / 2 + 30)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Number of Bites");

            svg_time.append("text")
                .attr("x", margin_time.left + chartWidth_time / 2)
                .attr("y", height_time - 5)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Time (Month-Year)");


            // ---------- TEMP CHART ----------
            const svg_temp = d3.select("#svg-temp");
            const width_temp = +svg_temp.attr("width");
            const height_temp = +svg_temp.attr("height");
            const margin_temp = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_temp = width_temp - margin_temp.left - margin_temp.right;
            const chartHeight_temp = height_temp - margin_temp.top - margin_temp.bottom;

            const g_temp = svg_temp.append("g")
                .attr("transform", `translate(${margin_temp.left},${margin_temp.top})`);

            const xScale_temp = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_temp]);

            const yScale_temp = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.avgTemp))
                .range([chartHeight_temp, 0]);

            const time_temp_line = d3.line()
                .x((d, i) => xScale_temp(i))
                .y(d => yScale_temp(d.avgTemp));

            g_temp.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "#F4D35E")
                .attr("stroke-width", 2)
                .attr("d", time_temp_line);

            const xAxis_temp = d3.axisBottom(xScale_temp)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

            g_temp.append("g")
                .attr("transform", `translate(0,${chartHeight_temp})`)
                .call(xAxis_temp)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            const yAxis_temp = d3.axisLeft(yScale_temp);
            g_temp.append("g").call(yAxis_temp);

            svg_temp.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_temp / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Average Temperature(F)");

            svg_temp.append("text")
                .attr("x", margin_temp.left + chartWidth_temp / 2)
                .attr("y", height_temp - 5)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Time (Month-Year)");


            // ---------- PRECIP CHART ----------
            const svg_precip = d3.select("#svg-precip");
            const width_precip = +svg_precip.attr("width");
            const height_precip = +svg_precip.attr("height");
            const margin_precip = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_precip = width_precip - margin_precip.left - margin_precip.right;
            const chartHeight_precip = height_precip - margin_precip.top - margin_precip.bottom;

            const g_precip = svg_precip.append("g")
                .attr("transform", `translate(${margin_precip.left},${margin_precip.top})`);

            const xScale_precip = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_precip]);

            const yScale_precip = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.avgPrecip))
                .range([chartHeight_precip, 0]);

            const time_precip_line = d3.line()
                .x((d, i) => xScale_precip(i))
                .y(d => yScale_precip(d.avgPrecip));

            g_precip.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "#3ec9c1")
                .attr("stroke-width", 2)
                .attr("d", time_precip_line);

            const xAxis_precip = d3.axisBottom(xScale_precip)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

            g_precip.append("g")
                .attr("transform", `translate(0,${chartHeight_precip})`)
                .call(xAxis_precip)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            const yAxis_precip = d3.axisLeft(yScale_precip);
            g_precip.append("g").call(yAxis_precip);

            svg_precip.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_precip / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Average Precipitation");

            svg_precip.append("text")
                .attr("x", margin_precip.left + chartWidth_precip / 2)
                .attr("y", height_precip - 5)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Time (Month-Year)");


            // ============ VERTICAL LINE INTERACTION ============
            const allSVGs = [
                { svg: svg_time, g: g_time, xScale: xScale_time, height: chartHeight_time },
                { svg: svg_temp, g: g_temp, xScale: xScale_temp, height: chartHeight_temp },
                { svg: svg_precip, g: g_precip, xScale: xScale_precip, height: chartHeight_precip }
            ];

            allSVGs.forEach(({ g, height }) => {
                g.append("line")
                    .attr("class", "vline")
                    .attr("y1", 0)
                    .attr("y2", height)
                    .attr("stroke", "gray")
                    .attr("stroke-dasharray", "4")
                    .style("opacity", 0);
            });

            // Add hover behavior to show vertical lines during mousemove
            allSVGs.forEach(({ svg, g, xScale }) => {
                svg.on("mousemove", function (event) {
                    const [mouseX] = d3.pointer(event);
                    const chartX = mouseX - 70; // Adjust for margin

                    const index = Math.round(xScale.invert(chartX));
                    if (index >= 0 && index < monthlyData.length) {
                        allSVGs.forEach(({ g, xScale }) => {
                            g.select(".vline")
                                .attr("x1", xScale(index))
                                .attr("x2", xScale(index))
                                .style("opacity", 1);
                        });
                    }
                });

                svg.on("mouseleave", function () {
                    allSVGs.forEach(({ g }) => {
                        g.select(".vline").style("opacity", 0);
                    });
                });
            });

        }

        requestData();
    </script>

    <script>

        const imageFilenames = [
            "American_Bulldog.png",
            "Australian_Shepherd.png",
            "Beagle.png",
            "Bernese_Mountain_Dog.png",
            "Boston_Terrier.png",
            "Boxer.png",
            "Cane_Corso.png",
            "Doberman_Pinscher.png",
            "French_Bulldog.png",
            "German_Shepherd.png",
            "German_Shorthaired_Pointer.png",
            "Golden_Retriever.png",
            "Great_Dane.png",
            "Labrador_Retriever.png",
            "Pembroke_Welsh_Corgi.png",
            "Rottweiler.png",
            "Siberian_Husky.png"
        ];

        // Map framework
        mapboxgl.accessToken = 'pk.eyJ1Ijoia3g2NCIsImEiOiJjbGkzd2E1dmsxMzNoM2twY2p2azF0bGVlIn0.t_v73kaAMUtoGBPESpw3uA';

        const map = new mapboxgl.Map({
            container: 'mapCanvas',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [-74.006, 40.7128],
            zoom: 10
        });

        const geocoder = new MapboxGeocoder({
            accessToken: mapboxgl.accessToken,
            mapboxgl: mapboxgl,
            marker: true,
            placeholder: "Search for your location...",
            zoom: 14
        });

        document.getElementById('geocoder-container').appendChild(geocoder.onAdd(map));

        let jsonData = null;
        let selectMode = false;
        let marker = null;

        map.on("click", (e) => {
            if (!selectMode) return;

            const { lng, lat } = e.lngLat;

            if (marker) {
                marker.setLngLat([lng, lat]);
            } else {
                marker = new mapboxgl.Marker()
                    .setLngLat([lng, lat])
                    .addTo(map);
            }

            map.flyTo({ center: [lng, lat], zoom: 15 });

            document.getElementById("location-info").innerText = `Selected Location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;

            selectMode = false;
        });

        let zipCentroidGeoJSON = null;


        // Load the  files
        Promise.all([
            d3.csv("zip_df.csv"),
            d3.json("nyc_zip_codes_with_centroids.geojson"),
            d3.json("nyc_open_space.geojson")
        ]).then(([zipData, zipGeoJSON, parkGeoJSON]) => {

            const biteByZip = {};
            const dogsByZip = {};

            zipData.forEach(d => {
                biteByZip[d.zip_code] = +d.number_of_bites;
                dogsByZip[d.zip_code] = +d.number_of_dogs;
                d.top_biter_by_bite_ratio = d.top_biter_by_bite_ratio?.trim();
            });

            const zipCentroidFeatures = [];

            zipGeoJSON.features.forEach(f => {
                const zip = f.properties.postcode || f.properties.ZIPCODE || f.properties.zip || f.properties.postalCode;
                const record = zipData.find(d => d.zip_code === zip);
                const numBites = biteByZip[zip] || 0;
                const numDogs = dogsByZip[zip] || 0;
                const topBiter = record?.top_biter_by_bite_ratio || null;
                f.properties.number_of_bites = numBites;
                f.properties.number_of_dogs = numDogs;

                if (f.properties.centroid_lon && f.properties.centroid_lat) {
                    zipCentroidFeatures.push({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [f.properties.centroid_lon, f.properties.centroid_lat]
                        },
                        properties: {
                            zip: zip,
                            number_of_bites: numBites,
                            number_of_dogs: numDogs,
                            top_biter_by_bite_ratio: topBiter
                        }
                    });
                }
            });

            zipCentroidGeoJSON = {
                type: 'FeatureCollection',
                features: zipCentroidFeatures
            };

            console.log("Number of ZIP dots created:", zipCentroidFeatures.length);

            map.on("load", () => {


                // ---- Parks layer ----
                map.addSource('parks', {
                    type: 'geojson',
                    data: parkGeoJSON
                });

                map.addLayer({
                    'id': 'park-fills',
                    'type': 'fill',
                    'source': 'parks',
                    'paint': {
                        'fill-color': '#72c27e',
                        'fill-opacity': 0.6
                    }
                });

                // map.addLayer({
                //     'id': 'park-borders',
                //     'type': 'line',
                //     'source': 'parks',
                //     'paint': {
                //         'line-color': '#2e8b57',
                //         'line-width': 1
                //     }
                // });

                const parkPopup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: false
                });

                map.on('mouseenter', 'park-fills', (e) => {
                    map.getCanvas().style.cursor = 'pointer';
                    const parkName = e.features[0].properties.PARK_NAME || "Unnamed Park";
                    const coordinates = e.lngLat;

                    parkPopup
                        .setLngLat(coordinates)
                        .setHTML(`<strong>${parkName}</strong>`)
                        .addTo(map);
                });

                map.on('mouseleave', 'park-fills', () => {
                    map.getCanvas().style.cursor = '';
                    parkPopup.remove();
                });


                // ---- ZIP shape layer ---
                map.addSource('zipcodes', {
                    type: 'geojson',
                    data: zipGeoJSON
                });

                map.addLayer({
                    'id': 'zip-dog-fills',
                    'type': 'fill',
                    'source': 'zipcodes',
                    'paint': {
                        'fill-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'number_of_dogs'],
                            0, '#ffffcc',
                            500, '#a1dab4',
                            2000, '#41b6c4',
                            4000, '#2c7fb8',
                            6000, '#08306b'
                        ],
                        'fill-opacity': 0.3

                    }
                });




                // ---- ZIP centroid dots ----
                map.addSource('zip-centroids', {
                    type: 'geojson',
                    data: zipCentroidGeoJSON
                });

                map.addLayer({
                    'id': 'zip-centroid-dots',
                    'type': 'circle',
                    'source': 'zip-centroids',
                    'paint': {
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['get', 'number_of_bites'],
                            0, 4,
                            500, 12
                        ],
                        'circle-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'number_of_bites'],
                            0, '#ffe082',
                            50, '#feb24c',
                            200, '#fd8d3c',
                            400, '#f03b20',
                            600, '#bd0026'
                        ],
                        'circle-opacity': 0.7
                        ,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-width': 1.5
                    }
                });

                // ---- ZIP dot hover popup ----
                const zipPopup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: false
                });

                map.on('mouseenter', 'zip-centroid-dots', (e) => {
                    map.getCanvas().style.cursor = 'pointer';
                    const props = e.features[0].properties;
                    const coordinates = e.lngLat;

                    zipPopup
                        .setLngLat(coordinates)
                        .setHTML(`<strong>ZIP: ${props.zip}</strong><br>Bites: ${props.number_of_bites}<br>Dogs: ${props.number_of_dogs}`)

                        .addTo(map);
                });

                map.on('mouseleave', 'zip-centroid-dots', () => {
                    map.getCanvas().style.cursor = '';
                    zipPopup.remove();
                });

                map.addSource('breed-icon-source', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: []
                    }
                });

                map.addLayer({
                    id: 'breed-icon-layer',
                    type: 'symbol',
                    source: 'breed-icon-source',
                    layout: {
                        'icon-image': ['get', 'icon'],
                        'icon-size': 0.05,
                        'icon-allow-overlap': true
                    }
                });



                imageFilenames.forEach(filename => {
                    const name = filename.replace('.png', '');
                    map.loadImage(`images/${filename}`, (error, image) => {
                        if (error) return console.error(`Image ${filename} failed to load:`, error);
                        if (!map.hasImage(name)) {
                            map.addImage(name, image);
                        }
                    });
                });



            });

        });


        function toggleLayer(checkbox, layerBaseId) {
            const layerIds = [layerBaseId];

            if (layerBaseId.includes('fills')) {
                layerIds.push(layerBaseId.replace('fills', 'borders'));
            }

            layerIds.forEach(layer => {
                if (!map.getLayer(layer)) return;
                map.setLayoutProperty(layer, 'visibility', checkbox.checked ? 'visible' : 'none');
            });
        }

        function createLegend({ label, layerId, colors, thresholds }) {
            const container = document.getElementById("layer-buttons");

            const checkboxLabel = document.createElement("label");
            checkboxLabel.innerHTML = `<input type="checkbox" onchange="toggleLayer(this, '${layerId}')" checked> ${label}`;
            container.appendChild(checkboxLabel);

            const legendWrapper = document.createElement("div");
            legendWrapper.className = "discrete-legend";

            const legendBar = document.createElement("div");
            legendBar.className = "legend-bar";
            colors.forEach(color => {
                const step = document.createElement("div");
                step.className = "legend-step";
                step.style.background = color;
                legendBar.appendChild(step);
            });
            legendWrapper.appendChild(legendBar);

            const labelRow = document.createElement("div");
            labelRow.className = "legend-labels";
            thresholds.forEach(value => {
                const span = document.createElement("span");
                span.textContent = value;
                labelRow.appendChild(span);
            });
            legendWrapper.appendChild(labelRow);

            container.appendChild(legendWrapper);
        }


        createLegend({
            label: "Bite Incidents",
            layerId: "zip-centroid-dots",
            colors: ["#ffe082", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
            thresholds: ["0", "50", "200", "400", "600+"]
        });



        createLegend({
            label: "Dog Population Distribution",
            layerId: "zip-dog-fills",
            colors: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#08306b"],
            thresholds: ["0", "500", "2000", "4000", "6000+"]
        });


        createLegend({
            label: "Open Spaces / Parks",
            layerId: "park-fills",
            colors: ["#ffffff", "#72c27e"],
            thresholds: ["Other Areas", "Open Spaces / Parks"]
        });


        let activeBreed = null;

        function updateBreedIconLayer(breed) {
  // If clicked breed is already active, clear it
  if (activeBreed === breed) {
    map.getSource('breed-icon-source').setData({
      type: 'FeatureCollection',
      features: []
    });
    activeBreed = null;
    return;
  }

  // Otherwise update to new breed
  activeBreed = breed;

  const filteredFeatures = zipCentroidGeoJSON.features.filter(f =>
    f.properties.top_biter_by_bite_ratio === breed
  ).map(f => ({
    type: 'Feature',
    geometry: f.geometry,
    properties: {
      icon: breed.replace(/ /g, '_')
    }
  }));

  map.getSource('breed-icon-source').setData({
    type: 'FeatureCollection',
    features: filteredFeatures
  });
}

        const grid = document.getElementById('image-button-grid');


        imageFilenames.forEach(filename => {
            const iconId = filename.replace('.png', '');
            map.loadImage(`images/${filename}`, (error, image) => {
                if (error) {
                    console.warn(`Could not load image ${filename}:`, error);
                    return;
                }
                if (!map.hasImage(iconId)) {
                    map.addImage(iconId, image);
                }
            });
        });

        imageFilenames.forEach(filename => {
            const breedName = filename.replace('.png', '').replace(/_/g, ' ');

            const btn = document.createElement('button');
            btn.style.display = 'flex';
            btn.style.flexDirection = 'column';
            btn.style.alignItems = 'center';
            btn.style.padding = '0';

            const img = document.createElement('img');
            img.src = `images/${filename}`;
            img.alt = breedName;

            const label = document.createElement('span');
            label.textContent = breedName;
            label.style.fontSize = '12px';
            label.style.marginTop = '4px';
            label.style.color = '#041F3D';
            label.style.textAlign = 'center';

            btn.appendChild(img);
            btn.appendChild(label);
            btn.onclick = () => updateBreedIconLayer(breedName);
            grid.appendChild(btn);
        });




    </script>



</body>