<html>

<head>
    <meta charset="UTF-8">

    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script
        src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.min.js"></script>
    <link rel="stylesheet"
        href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.css">
    <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;500;600;700;800&display=swap"
        rel="stylesheet">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        body {
            margin: 0px;
            font-family: 'Baloo 2', Arial;
            color: #041F3D;
            display: flex;
            flex-direction: column;
        }

        .container-centered {
            width: 96%;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            padding-bottom: 30px;
        }

        h2 {
            font-size: 28px;
            font-weight: 700;
            color: #FF5800;
            margin-top: 40px;
            margin-bottom: 40px;
        }

        h4 {
            font-size: 18px;
            font-weight: 700;
            color: #FF5800;
            margin-top: 40px;
            margin-bottom: 60px;
        }

        #text {
            margin-left: 500px;
            margin-right: 500px
        }

        .colored-bg {
            background-color: #ffefda
        }

        .session {
            padding-top: 40px;
            padding-bottom: 40px;
        }

        .map-container {
            display: flex;
            flex-direction: row;
            width: 70%;
            height: 70vh;
            margin: 0 auto;
            margin-top: 50px;
            box-sizing: border-box;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        #mapCanvas {
            flex: 1;
            height: 100%;
        }

        .sidebar {
            width: 250px;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            padding: 12px 16px;
            overflow-y: auto;
            z-index: 2;
        }

        #geocoder-container {
            position: absolute;
            top: 10px;
            left: 20px;
            width: 50%;
            z-index: 3;
        }



        #image-button-grid {
            margin-top: auto;
        }




        .discrete-legend {
            margin: 8px 0 16px 0;
        }

        .legend-bar {
            display: flex;
            height: 14px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
            box-shadow: inset 0 0 0 1px #ccc;
        }

        .legend-step {
            flex: 1;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #041F3D;
            padding: 0 2px;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .image-grid button {
            border: none;
            background: none;
            padding: 0;
            cursor: pointer;
        }

        .image-grid img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease;
        }

        .image-grid img:hover {
            transform: scale(1.05);
        }

        .descriptions {
            margin-left: 15%;
            margin-right: 15%;
            text-align: left;
        }

        h3 {
            margin-top: 0px;

        }

        .y-info {
            position: absolute;
            background: white;
            border: 3px solid;
            border-radius: 10px;
            padding: 8px 12px;
            font-family: sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: #1a1a1a;
            pointer-events: none;
            opacity: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .temp-bite {
            background-color: #FCF0DC;
            border-radius: 10px;
            padding: 10px;
            height: 100%;
        }

        .precip-bite {
            background-color: #6ac6c090;
            border-radius: 10px;
            padding: 10px;
            height: 100%;
        }

        .special {
            background-color: #f0925388;
            border-radius: 10px;
            padding: 10px;
            height: 100%;
        }

    </style>


</head>

<body>

    <!--Introduction-->
    <div class="session container-centered">
        <div>
            <img src="images/Bite.png" alt="Dog Bite Cartoon" width="600"
                style="margin-top: -40px; margin-bottom: -40px;">
            <h1 style="font-weight:800; font-size: 36px; margin-bottom: 5px">
                Bitten by the Numbers: A Data Story on NYC Dogs
            </h1>
            <h3 style="margin-top: 0px; color: #FF5800">Flavia Jiang, Curtis Xu, Xinyi Zhou</h3>

            <div class="descriptions" style="margin-top: 40px; padding-bottom: 30px;">
                <p>
                    Have you ever wondered where and when dogs bite the most in New York City?
                    From quiet neighborhoods in Queens to bustling blocks in Manhattan, <strong>more
                        than 28,000 dog bite incidents </strong> were reported across the five boroughs between
                    2018 and 2023. Using data from the New York City Department of Health and
                    Mental Hygiene (NYC DOHMH), we dive deep into these reports to uncover trends
                    and surprising patterns.
                </p>

                <p>
                    In this article, you&#39;ll find breakdowns of <strong>dog bite incidents by breed, age,
                        gender, spaying or neutering status, time of year, and neighborhood </strong>. Whether
                    you're a dog owner hoping to prevent aggressive behavior or a city dweller
                    just trying to steer clear of risky encounters, our goal is to provide insights
                    that are both informative and practical. Understanding when, where, and under
                    what circumstances dogs are most likely to bite can <strong>help all of us — humans and
                        dogs — coexist a little more safely in this crowded city.</strong>
                </p>
            </div>
        </div>
    </div>

    <!--Bite incidents by breed-->
    <div class="session colored-bg">
        <div id="container-breed" class="container-centered">
            <h2>1. Are These Breeds Friendlier (or Bite-ier) Than You Expected?</h2>
            <svg id="svg-breed" height="490" width="960"></svg>
            <div class="descriptions">
                <p>
                    Which breeds bite more or less than expected? <strong>We compared bite frequency 
                    scores</strong> — normalized by the number of licensed dogs per breed —<strong> with 
                    owner-rated aggressiveness scores</strong> from the 2024 Forbes Advisor Pet Insurance 
                    Survey, where higher scores reflect greater perceived aggressiveness.
                </p>
                <p>
                    Breeds like American Bulldogs and German Shepherds bite in line with owner perceptions. 
                    Golden and Labrador Retrievers bite more than expected, while Miniature Schnauzers and 
                    Pomeranians bite less. Cavalier King Charles Spaniels and Havanese are gentle as 
                    expected.
                </p>
                <p>
                    This chart is meant to inform, not stereotype. <strong>Use the sorting buttons at the 
                    top of the chart</strong> to explore the patterns for yourself!
                </p>
            </div>
        </div>
    </div>

    <!--Bite incidents by gender x spay & neuter-->
    <div class="session">
        <div id="container-gender" class="container-centered">
            <h2 style="margin-bottom: 20px">2. Spaying or Neutering Makes Dogs Over 2x Less Likely to Bite</h2>
            <svg id="svg-gender" height="350" width="560" style="margin-bottom: 20px"></svg>
            <div class="descriptions">
                <p>
                Spaying and neutering are strongly linked to reduced biting behavior in dogs. <strong>Hover over 
                the nodes</strong> to explore each data point. As shown in the chart, spayed female dogs are 
                <strong>2.5 times less likely to bite</strong> than unspayed females, and neutered male dogs 
                are <strong>2.9 times less likely </strong> to bite than their unneutered counterparts.
            </p>
            <p>
                For the safety of your dog, yourself, and your community, spaying or neutering is worth considering. 
                It also offers additional health benefits - learn more 
                in <a href="https://www.avma.org/resources-tools/pet-owners/petcare/spaying-and-neutering" target="_blank">this 
                article</a> from the American Veterinary Medical Association.
            </p>

            </div>

        </div>
    </div>

    <!--Bite incidents by age-->
    <div class="session colored-bg">
        <div id="container-age" class="colored-bg container-centered">
            <h2>3. Growing Up Means Biting Less—for Dogs, Too</h2>
            <svg id="svg-age" height="520" width="580"></svg>
        </div>
    </div>

    <!--Bite incidents by time-->
    <div class="session">
        <div id="container-time" class="container-centered">
            <h2>4. Any relationships Between Dog Bites & External Environmental Factors?</h2>
            <div class="tiem-description"
                style="display:flex; flex-direction:row; gap:50px; padding-left: 150px; padding-right: 150px; justify-content: flex-start; align-items: flex-start; text-align: left;">
                <div class="temp-bite">
                    <p><strong>Relationship between temperature and number of bites</strong></p>
                    <p>The line graphs show a clear correlation between rising temperatures and an increase in dog
                        bites,
                        suggesting that dogs may become more aggressive in hot weather, leading to pent-up energy and
                        frustration. This trend highlights the potential impact of seasonal temperature changes on dog
                        behavior and bite incidents, warranting further investigation into underlying causes and
                        preventive measures.
                    </p>
                </div>
                <div class="precip-bite">
                    <p><strong>Relationship between precipitation and number of bites</strong></p>
                    <p>The line graphs also demonstrate no significant correlation between the number of dog bites and
                        precipitation
                        Levels. Over the years, the pattern of precipitation changes has fluctuated considerably. This
                        may be due to the fact that dog walking habits remain relatively consistent regardless of
                        humidity.
                        Alternatively, factors such as temperature or human activity patterns may have a greater impact
                        on bite incidents than rainfall alone.</p>
                </div>
                <div class="special">
                    <p><strong>Special Finding<br>A Sharp decline between 2020 and 2021</strong></p>
                    <p>The number of dog bites dropped significantly in April 2020, even as temperatures rose—a trend
                        that diverges
                        from the typical seasonal pattern. This anomaly coincides with the onset of COVID-19 lockdowns,
                        suggesting
                        that reduced outdoor activity and fewer dog walks during quarantine likely contributed to the
                        decline.
                        This observation highlights how human behavior, not just environmental factors like temperature,
                        can
                        influence bite incidents.
                    </p>
                </div>

            </div>
            <div
                style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 50px; padding-bottom: 30px; padding-top:100px;">
                <svg id="svg-time" height="450" width="650" style="font-family: 'Baloo 2', Comic Sans MS, Arial;"></svg>
                <div style="display:flex; flex-direction:column; gap:30px;">
                    <svg id="svg-temp" height="300" width="450"
                        style="font-family: 'Baloo 2', Comic Sans MS, Arial;"></svg>
                    <svg id="svg-precip" height="300" width="450"
                        style="font-family: 'Baloo 2', Comic Sans MS, Arial;"></svg>
                </div>
                <div id="y-info-bites" class="y-info"></div>
                <div id="y-info-temp" class="y-info"></div>
                <div id="y-info-precip" class="y-info"></div>

            </div>

        </div>
    </div>

    <!--Bite incidents by neighborhood-->
    <div class="session colored-bg">
        <div id="container-zip" class="colored-bg container-centered">
            <h2>5. The Bite Map</h2>
            <h4> Explore NYC's Dog Bites and its potential spatial factors</h4>
            <div class="descriptions">
                <p>
                    This interactive map invites New York City residents to explore patterns in dog bite incidents,
                    alongside contextual factors such as dog population density and the presence of open spaces and
                    parks. By toggling between data layers and visualizing bite frequency by ZIP code, users can begin
                    to understand where bites happen—and what might influence them.
                </p>

                <p>
                    <strong>Two key findings emerged from this data:</strong>
                </p>

                <p>
                    <strong>1. Dog bite frequency does not directly correlate with dog population density.</strong><br>
                    Some ZIP codes with the highest numbers of dogs report only moderate or even low bite incidents.
                    This suggests that a high dog population alone is not a reliable predictor of bite risk.
                </p>

                <p>
                    <strong>2. Open spaces and park access may be associated with bite frequency—but not
                        consistently.</strong><br>
                    The ZIP code with the highest number of recorded dog bites also contains over 20 parks and open
                    spaces. While this suggests a potential link between public gathering areas and bite frequency, the
                    pattern does not hold true across all neighborhoods, indicating that additional social or
                    environmental factors may be at play.
                </p>

                <p>
                    In addition to area-based insights, this map offers a unique tool for breed-specific analysis. Users
                    can click on breed icons to identify the ZIP codes where each breed has the highest bite rate,
                    providing a visual sense of territorial bite dominance. This feature may also help shed light on
                    perceived aggressiveness patterns among certain breeds.
                </p>

                <p>
                    Together, these layers empower NYC residents to better understand when and where dog bites are most
                    likely to occur—and to consider how urban context, breed characteristics, and public space usage may
                    intersect in complex ways.
                </p>
            </div>

        </div>

        <div class="map-container">
            <div id="mapCanvas"></div>
            <div id="layer-control" class="sidebar">
                <div id="layer-buttons"></div>
                <h4 style="margin-bottom: 8px; text-align: center; font-size: 14px; font-weight: bold; color: #041F3D;">
                    Tap a dog to discover its top territory for bites
                </h4>


                <div id="image-button-grid" class="image-grid"></div>
            </div>
            <div id="geocoder-container"></div>
        </div>


    </div>



    <script>
        const requestData = async () => {

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Chart 1: Bite incidents by breed
            const breedData = await d3.csv("breed_df.csv");

            breedData.forEach(d => {
                d.bite_score = 16 - +d.bite_score_ranking;
                d.aggresiveness_score = 16 - +d.aggresiveness_score_ranking;
            });

            // Default for toggle
            let currentSort = "bite";

            const svg_breed = d3.select("#svg-breed");
            const width_breed = +svg_breed.attr("width");
            const height_breed = +svg_breed.attr("height");
            const margin_breed = { top: 90, right: 20, bottom: 60, left: 40 };
            const chartWidth_breed = width_breed - margin_breed.left - margin_breed.right;
            const chartHeight_breed = height_breed - margin_breed.top - margin_breed.bottom;

            const g_breed = svg_breed.append("g")
                .attr("transform", `translate(${margin_breed.left},${margin_breed.top})`);

            // Update chart based on current sort
            function updateChart() {
                const sortedData = [...breedData].sort((a, b) =>
                    currentSort === "bite" ?
                        d3.descending(+a.bite_score, +b.bite_score) :
                        d3.descending(+a.aggresiveness_score, +b.aggresiveness_score)
                );

                xScale_breed.domain(sortedData.map(d => d.breed));

                // Transition for bars and images
                const t = svg_breed.transition().duration(750);

                g_breed.selectAll(".breed-group")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("transform", d => `translate(${xScale_breed(d.breed)},0)`);

                g_breed.selectAll(".bar-bite")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("y", d => yScale_breed(d.bite_score))
                    .attr("height", d => chartHeight_breed / 2 - yScale_breed(d.bite_score));

                g_breed.selectAll(".bar-agg")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("height", d => yScale_breed_neg(d.aggresiveness_score));

                g_breed.selectAll(".breed-image")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("cx", xScale_breed.bandwidth() / 2);

                g_breed.selectAll(".breed-img")
                    .data(sortedData, d => d.breed)
                    .transition(t)
                    .attr("x", -xScale_breed.bandwidth() * 0.2);

                updateSortToggle();
            }

            // Create or update the sort toggle button
            function updateSortToggle() {
                g_breed.selectAll(".sort-toggle").remove();

                const toggle = g_breed.append("g")
                    .attr("class", "sort-toggle")
                    .attr("transform", `translate(${chartWidth_breed / 2 - 250}, -85)`);

                // Add toggle background
                toggle.append("rect")
                    .attr("width", 500)
                    .attr("height", 45)
                    .attr("rx", 20)
                    .attr("ry", 20)
                    .attr("fill", "white")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                // Add label
                toggle.append("text")
                    .attr("x", 60)
                    .attr("y", 27.5)
                    .attr("text-anchor", "middle")
                    .text("Sort By:")
                    .style("fill", "#FF5800")
                    .style("font-size", "18px")
                    .style("font-weight", "bold");

                // Add two options
                toggle.append("text")
                    .attr("x", 170)
                    .attr("y", 27.5)
                    .attr("text-anchor", "middle")
                    .text("Bite Frequency")
                    .style("fill", "#041F3D")
                    .style("font-size", "18px")
                    .style("font-weight", currentSort === "bite" ? "bold" : "normal")
                    .style("cursor", "pointer")
                    .on("mouseover", function () {
                        d3.select(this).style("cursor", "pointer");
                    })
                    .on("click", () => {
                        if (currentSort !== "bite") {
                            currentSort = "bite";
                            updateChart();
                        }
                    });

                toggle.append("text")
                    .attr("x", 360)
                    .attr("y", 27.5)
                    .attr("text-anchor", "middle")
                    .text("Owner-Rated Aggressiveness")
                    .style("fill", "#041F3D")
                    .style("font-size", "18px")
                    .style("font-weight", currentSort === "agg" ? "bold" : "normal")
                    .style("cursor", "pointer")
                    .on("mouseover", function () {
                        d3.select(this).style("cursor", "pointer");
                    })
                    .on("click", () => {
                        if (currentSort !== "agg") {
                            currentSort = "agg";
                            updateChart();
                        }
                    });
            }

            // Create the initial chart
            g_breed.append("line")
                .attr("x1", 0)
                .attr("y1", chartHeight_breed / 2)
                .attr("x2", chartWidth_breed)
                .attr("y2", chartHeight_breed / 2)
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .lower();

            const xScale_breed = d3.scaleBand()
                .domain(breedData.map(d => d.breed))
                .range([0, chartWidth_breed])
                .padding(0.4);

            const yScale_breed = d3.scaleLinear()
                .domain([0, 15])
                .range([chartHeight_breed / 2, 0]);

            const yScale_breed_neg = d3.scaleLinear()
                .domain([0, 15])
                .range([0, chartHeight_breed / 2]);

            // Add y-axis titles
            g_breed.append("text")
                .attr("y", 5)
                .attr("x", chartWidth_breed / 2)
                .attr("text-anchor", "middle")
                .text("Bite Frequency")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            g_breed.append("text")
                .attr("y", chartHeight_breed - margin_breed.bottom + 70)
                .attr("x", chartWidth_breed / 2)
                .attr("text-anchor", "middle")
                .text("Owner-Rated Aggressiveness")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Create a group for each breed 
            const breedGroups = g_breed.selectAll(".breed-group")
                .data(breedData)
                .join("g")
                .attr("class", "breed-group")
                .attr("transform", d => `translate(${xScale_breed(d.breed)},0)`);

            // Add bars
            breedGroups.append("rect")
                .attr("class", "bar-bite")
                .attr("width", xScale_breed.bandwidth())
                .attr("y", d => yScale_breed(d.bite_score))
                .attr("height", d => chartHeight_breed / 2 - yScale_breed(d.bite_score))
                .attr("fill", "#ff8c42")
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("opacity", 0.8);

            breedGroups.append("rect")
                .attr("class", "bar-agg")
                .attr("width", xScale_breed.bandwidth())
                .attr("y", chartHeight_breed / 2)
                .attr("height", d => yScale_breed_neg(d.aggresiveness_score))
                .attr("fill", "#3ec9c1")
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("opacity", 0.8);

            // Add image circles
            breedGroups.append("circle")
                .attr("class", "breed-image")
                .attr("cx", xScale_breed.bandwidth() / 2)
                .attr("cy", chartHeight_breed / 2)
                .attr("r", xScale_breed.bandwidth() * 0.75)
                .attr("fill", "white")
                .attr("stroke", "#041f3d")
                .attr("stroke-width", 2);

            // Add images
            breedGroups.append("image")
                .attr("class", "breed-img")
                .attr("xlink:href", d => `images/${d.breed.replaceAll(' ', '_')}.png`)
                .attr("x", -xScale_breed.bandwidth() * 0.2)
                .attr("y", chartHeight_breed / 2 - xScale_breed.bandwidth() * 0.65)
                .attr("width", xScale_breed.bandwidth() * 1.4)
                .attr("height", xScale_breed.bandwidth() * 1.4);

            // Create tooltip
            const tooltip = g_breed.append("g")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            tooltip.append("rect")
                .attr("width", 440)
                .attr("height", 130)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 3);

            tooltip.append("image")
                .attr("class", "tooltip-img")
                .attr("x", 12)
                .attr("y", 10)
                .attr("width", 110)
                .attr("height", 110);

            tooltip.append("text")
                .attr("class", "tooltip-title")
                .attr("x", 130)
                .attr("y", 40)
                .style("font-size", "18px")
                .style("font-weight", "bold");

            tooltip.append("text")
                .attr("class", "tooltip-bite")
                .attr("x", 130)
                .attr("y", 70)
                .style("font-size", "16px");

            tooltip.append("text")
                .attr("class", "tooltip-agg")
                .attr("x", 130)
                .attr("y", 100)
                .style("font-size", "16px");

            // Hover-over functions
            breedGroups.on("mouseover", function (event, d) {
                d3.select(this).selectAll("rect")
                    .attr("opacity", 1)
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                // Dim other breeds
                breedGroups.filter(dd => dd !== d).selectAll("rect")
                    .attr("opacity", 0.3);

                const [mouseX, mouseY] = d3.pointer(event, svg_breed.node());
                const tooltipWidth = 440;
                const tooltipHeight = 130;
                const padding = 5;
                const barPadding = 20;

                let x;
                if (mouseX > width_breed - tooltipWidth - padding) {
                    // Tooltip will appear to the left
                    x = mouseX - tooltipWidth - barPadding - 50;
                } else {
                    // Tooltip will appear to the right
                    x = mouseX + padding - 20;
                }

                let y;
                if (mouseY < chartHeight_breed / 2 - 100) {
                    y = mouseY + padding;
                } else {
                    y = mouseY - tooltipHeight - padding;
                }

                // Boundary checks
                x = Math.max(padding, Math.min(x, width_breed - tooltipWidth - padding));
                y = Math.max(padding, Math.min(y, height_breed - tooltipHeight - padding));

                tooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);

                tooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);

                tooltip.select(".tooltip-img")
                    .attr("xlink:href", `images/${d.breed.replaceAll(' ', '_')}.png`);

                tooltip.select(".tooltip-title")
                    .text(d.breed);

                tooltip.select(".tooltip-bite")
                    .html(`Bite Frequency: <tspan style="font-weight:bold">${d.bite_score} out of 15</tspan>`);

                tooltip.select(".tooltip-agg")
                    .html(`Owner-Rated Aggressiveness: <tspan style="font-weight:bold">${d.aggresiveness_score} out of 15</tspan>`);
            })
                .on("mousemove", function (event) {
                    const [mouseX, mouseY] = d3.pointer(event, svg_breed.node());
                    const tooltipWidth = 440;
                    const tooltipHeight = 130;
                    const padding = 15;
                    const barPadding = 20;

                    let x;
                    if (mouseX > width_breed - tooltipWidth - padding) {
                        x = mouseX - tooltipWidth - barPadding - 50;
                    } else {
                        x = mouseX + padding - 20;
                    }

                    let y;
                    if (mouseY < chartHeight_breed / 2 - 100) {
                        y = mouseY + padding;
                    } else {
                        y = mouseY - tooltipHeight - padding;
                    }

                    x = Math.max(padding, Math.min(x, width_breed - tooltipWidth - padding));
                    y = Math.max(padding, Math.min(y, height_breed - tooltipHeight - padding));

                    tooltip.attr("transform", `translate(${x},${y})`);
                })
                .on("mouseout", function () {
                    breedGroups.selectAll("rect")
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");

                    tooltip.style("opacity", 0);
                });

            // Create axes
            const yAxis_breed = d3.axisLeft(yScale_breed)
                .tickValues([0, 3, 6, 9, 12, 15])
                .tickSizeOuter(0);

            g_breed.append("g")
                .attr("class", "y-axis")
                .call(yAxis_breed)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text").style("font-size", "14px").style("fill", "#041F3D").attr("dx", "-0.2em"));

            const yAxis_breed_neg = d3.axisLeft(yScale_breed_neg)
                .tickValues([0, 3, 6, 9, 12, 15])
                .tickSizeOuter(0);

            g_breed.append("g")
                .attr("transform", `translate(0,${chartHeight_breed / 2})`)
                .attr("class", "y-axis")
                .call(yAxis_breed_neg)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text").style("font-size", "14px").style("fill", "#041F3D").attr("dx", "-0.2em"));

            // Initialize the toggle
            updateSortToggle();

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Part 2: Bite incidents by gender x spay & neuter
            const genderData = await d3.csv("gender_spay_df.csv");

            genderData.forEach(d => {
                d.spayed_or_neutered = d.spayed_or_neutered === "True";
                d.bite_versus_population_ratio = +d.bite_versus_population_ratio;
            });

            const svg_gender = d3.select("#svg-gender");
            const width_gender = +svg_gender.attr("width");
            const height_gender = +svg_gender.attr("height");
            const margin_gender = { top: 40, right: 150, bottom: 80, left: 80 };
            const chartWidth_gender = width_gender - margin_gender.left - margin_gender.right;
            const chartHeight_gender = height_gender - margin_gender.top - margin_gender.bottom;

            const g_gender = svg_gender.append("g")
                .attr("transform", `translate(${margin_gender.left},${margin_gender.top})`);

            // Set up scales
            const maxValue = d3.max(genderData, d => d.bite_versus_population_ratio);
            const xScale_gender = d3.scaleLinear()
                .domain([0, maxValue * 1.1])
                .range([0, chartWidth_gender]);

            const yScale_gender = d3.scaleBand()
                .domain(["F", "M"])
                .range([0, chartHeight_gender])
                .padding(0.5);

            // Add vertical line at x=1 (average)
            const bg_gender = g_gender.append("g")
                .attr("class", "background-group");

            bg_gender.append("line")
                .attr("x1", xScale_gender(1))
                .attr("y1", 0)
                .attr("x2", xScale_gender(1))
                .attr("y2", chartHeight_gender)
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");

            bg_gender.append("text")
                .attr("x", xScale_gender(1) + 5)
                .attr("y", 20)
                .text("1 (average)")
                .style("font-size", "16px")
                .style("fill", "#041F3D");

            // Create lollipops
            const fg_gender = g_gender.append("g")
                .attr("class", "foreground-group");

            genderData.sort((a, b) => b.bite_versus_population_ratio - a.bite_versus_population_ratio);

            const genderGroups = fg_gender.selectAll(".gender-group")
                .data(genderData)
                .enter()
                .append("g")
                .attr("class", "gender-group");

            genderGroups.each(function (d) {
                const group = d3.select(this);
                const circleX = xScale_gender(d.bite_versus_population_ratio);
                const circleY = yScale_gender(d.gender) + yScale_gender.bandwidth() / 2;

                group.append("line")
                    .attr("x1", 0)
                    .attr("y1", circleY)
                    .attr("x2", circleX)
                    .attr("y2", circleY)
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                group.append("circle")
                    .attr("cx", circleX)
                    .attr("cy", circleY)
                    .attr("r", 16)
                    .attr("fill", d.spayed_or_neutered ? "#3ec9c1" : "#ff8c42")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2)
                    .attr("class", "gender-circle");

                group.append("text")
                    .attr("x", circleX)
                    .attr("y", circleY)
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .text(d3.format(".1f")(d.bite_versus_population_ratio))
                    .style("font-size", "16px")
                    .style("fill", "#041F3D")
                    .style("font-weight", "bold")
                    .style("pointer-events", "none");
            });

            // Add y-axis
            const yAxis_gender = d3.axisLeft(yScale_gender)
                .tickFormat(d => d === "F" ? "Female" : "Male")
                .tickSize(0)
                .tickPadding(7);

            g_gender.append("g")
                .call(yAxis_gender)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text")
                    .style("font-size", "16px")
                    .style("fill", "#041F3D")
                    .style("font-weight", "bold"));

            // Add x-axis
            const xAxis_gender = d3.axisBottom(xScale_gender).ticks(5);

            g_gender.append("g")
                .attr("transform", `translate(0,${chartHeight_gender})`)
                .call(xAxis_gender)
                .call(g => g.select(".domain")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line")
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text")
                    .style("font-size", "14px")
                    .style("fill", "#041F3D"));

            g_gender.append("text")
                .attr("x", chartWidth_gender / 2)
                .attr("y", chartHeight_gender + 60)
                .attr("text-anchor", "middle")
                .text("Bite Frequency Score")
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Add legend
            const legend = g_gender.append("g")
                .attr("transform", `translate(${chartWidth_gender - 100}, 20)`);

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 10)
                .attr("r", 10)
                .attr("fill", "#3ec9c1")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 1.5);

            legend.append("text")
                .attr("x", 25)
                .attr("y", 15)
                .text("Spayed/Neutered")
                .style("font-size", "16px")
                .style("fill", "#041F3D");

            legend.append("circle")
                .attr("cx", 10)
                .attr("cy", 40)
                .attr("r", 10)
                .attr("fill", "#ff8c42")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 1.5);

            legend.append("text")
                .attr("x", 25)
                .attr("y", 45)
                .text("NOT Spayed/Neutered")
                .style("font-size", "16px")
                .style("fill", "#041F3D");

            // Create tooltip
            const genderTooltip = g_gender.append("g")
                .attr("class", "gender-tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            genderTooltip.append("rect")
                .attr("width", 300)
                .attr("height", 80)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke-width", 4);

            genderTooltip.append("text")
                .attr("class", "tooltip-interpretation")
                .attr("x", 15)
                .attr("y", 30)
                .attr("fill", "#041F3D")
                .style("font-size", "16px")
                .style("font-family", "'Baloo 2', Comic Sans MS, Arial");

            // Hover-over events
            genderGroups.on("mouseover", function (event, d) {
                const borderColor = d.spayed_or_neutered ? "#3ec9c1" : "#ff8c42";
                d3.select(this).select(".gender-circle")
                    .attr("r", 20)
                    .attr("stroke-width", 3);

                genderTooltip.select("rect")
                    .attr("stroke", borderColor);

                const ratio = d.bite_versus_population_ratio.toFixed(2);
                const comparison = d.bite_versus_population_ratio > 1 ? "higher" : "lower";
                const gender = d.gender === "F" ? "Female" : "Male";
                const status = d.spayed_or_neutered ? "spayed/neutered" : "NOT spayed/neutered";

                const htmlContent = `<tspan style="font-weight:bold">${gender}</tspan> dogs that are <tspan style="font-weight:bold">${status}</tspan> have a bite rate <tspan style="font-weight:bold">${ratio}</tspan> times <tspan style="font-weight:bold">${comparison}</tspan> than expected.`;

                // Text wrapping
                const tooltipText = genderTooltip.select(".tooltip-interpretation");
                tooltipText.selectAll("*").remove();

                const maxCharsPerLine = 35;
                const words = htmlContent.split(' ');
                let line = [];
                let lineNumber = 0;
                const xPos = 15;
                const initialYPos = 30;
                const lineHeight = 20;

                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontFamily = "'Baloo 2', Comic Sans MS, Arial";
                tempDiv.style.fontSize = '16px';
                document.body.appendChild(tempDiv);

                words.forEach((word, i) => {
                    line.push(word);
                    tempDiv.innerHTML = line.join(' ');
                    const testWidth = tempDiv.offsetWidth;

                    if (testWidth > 280 && line.length > 1) {
                        line.pop();
                        tooltipText.append("tspan")
                            .attr("x", xPos)
                            .attr("y", initialYPos + (lineNumber * lineHeight))
                            .html(line.join(' '));

                        line = [word];
                        lineNumber++;
                    }
                });

                // Add the last line
                if (line.length > 0) {
                    tooltipText.append("tspan")
                        .attr("x", xPos)
                        .attr("y", initialYPos + (lineNumber * lineHeight))
                        .html(line.join(' '));
                }

                document.body.removeChild(tempDiv);

                const tooltipHeight = 50 + (lineNumber * lineHeight);
                genderTooltip.select("rect")
                    .attr("height", tooltipHeight);

                // Position tooltip
                const [mouseX, mouseY] = d3.pointer(event, svg_gender.node());
                const tooltipWidth = 300;
                const padding = 10;
                const pointerOffset = 15;

                let x = mouseX + tooltipWidth + padding > width_gender
                    ? mouseX - tooltipWidth - pointerOffset
                    : mouseX + pointerOffset;

                let y = mouseY - (tooltipHeight / 2);
                y = Math.max(padding, Math.min(y, height_gender - tooltipHeight - padding));

                genderTooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);
            })
                .on("mouseout", function () {
                    d3.select(this).select(".gender-circle")
                        .attr("r", 16)
                        .attr("stroke-width", 2);

                    genderTooltip.style("opacity", 0);
                })
                .on("mousemove", function (event) {
                    let [mouseX, mouseY] = d3.pointer(event, svg_gender.node());
                    mouseX = mouseX - 60;
                    const tooltipWidth = 300;
                    const tooltipHeight = +genderTooltip.select("rect").attr("height");
                    const padding = 10;
                    const pointerOffset = 15;

                    let x = mouseX + tooltipWidth + padding > width_gender
                        ? mouseX - tooltipWidth - pointerOffset
                        : mouseX + pointerOffset;

                    let y = mouseY - (tooltipHeight / 2);
                    y = Math.max(padding, Math.min(y, height_gender - tooltipHeight - padding));

                    genderTooltip.attr("transform", `translate(${x},${y})`);
                });


            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Chart 3: Bite incidents by age
            const ageData = await d3.csv("age_df.csv");

            const svg_age = d3.select("#svg-age");

            const width_age = +svg_age.attr("width");
            const height_age = +svg_age.attr("height");
            const margin_age = { top: 50, right: 90, bottom: 130, left: 10 };
            const chartWidth_age = width_age - margin_age.left - margin_age.right;
            const chartHeight_age = height_age - margin_age.top - margin_age.bottom;

            const g_age = svg_age.append("g")
                .attr("transform", `translate(${margin_age.left},${margin_age.top})`);

            ageData.forEach(d => {
                d.age = +d.age;
                d.bite_versus_population_ratio = +d.bite_versus_population_ratio;
                d.ageLabel = d.age === 1 ? "≤1" : d.age.toString();
            });

            // Set up scales
            const xScale_age = d3.scaleBand()
                .domain(ageData.map(d => d.ageLabel))
                .range([0, chartWidth_age])
                .padding(0.3);

            const maxRatio = d3.max(ageData, d => d.bite_versus_population_ratio);
            const yScale_age = d3.scaleLinear()
                .domain([0, maxRatio * 1.1])
                .range([chartHeight_age, 0]);

            // Add horizontal line at y=1
            g_age.append("line")
                .attr("x1", 0)
                .attr("y1", yScale_age(1))
                .attr("x2", chartWidth_age)
                .attr("y2", yScale_age(1))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");

            g_age.append("text")
                .attr("x", chartWidth_age - 10)
                .attr("y", yScale_age(1) - 12)
                .attr("text-anchor", "end")
                .text("1 (average)")
                .style("font-size", "18px")
                .style("fill", "#041F3D");

            // Add lollipops
            const colorScale = d3.scaleThreshold()
                .domain([0.8, 1.6])
                .range(["#ffd1a8", "#ff8c42", "#e65c00"]);

            const lollipopGroups = g_age.selectAll(".lollipop-group")
                .data(ageData)
                .join("g")
                .attr("class", "lollipop-group")
                .attr("transform", d => `translate(${xScale_age(d.ageLabel) + xScale_age.bandwidth() / 2},0)`);

            lollipopGroups.append("line")
                .attr("class", "lollipop-line")
                .attr("y1", yScale_age(0))
                .attr("y2", d => yScale_age(d.bite_versus_population_ratio))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            lollipopGroups.append("circle")
                .attr("class", "lollipop-circle")
                .attr("cy", d => yScale_age(d.bite_versus_population_ratio))
                .attr("r", 10)
                .attr("fill", d => colorScale(d.bite_versus_population_ratio))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            // x axis
            const xAxis = g_age.append("g")
                .attr("transform", `translate(0,${chartHeight_age})`)
                .call(d3.axisBottom(xScale_age));

            xAxis.selectAll("text")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#041F3D")
                .attr("dy", "1em");

            xAxis.append("text")
                .attr("x", chartWidth_age / 2)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .text("Age")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D")
                .style("font-family", "'Baloo 2', Comic Sans MS, Arial");

            xAxis.select(".domain")
                .attr("stroke-width", 2);

            xAxis.selectAll(".tick line")
                .attr("stroke-width", 2);

            // y axis
            const yAxis = g_age.append("g")
                .attr("transform", `translate(${chartWidth_age},0)`)
                .call(d3.axisRight(yScale_age).ticks(5));

            yAxis.select(".domain")
                .attr("stroke-width", 2);

            yAxis.selectAll(".tick line")
                .attr("stroke-width", 2);

            yAxis.selectAll("text")
                .style("font-size", "14px")
                .style("fill", "#041F3D")
                .attr("dx", "0.3em");

            g_age.append("text")
                .attr("y", -20)
                .attr("x", chartWidth_age - 60)
                .attr("text-anchor", "middle")
                .text("Bite Frequency Score")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Tooltip
            const ageTooltip = g_age.append("g")
                .attr("class", "age-tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            ageTooltip.append("rect")
                .attr("width", 350)
                .attr("height", 95)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke-width", 4);

            ageTooltip.append("text")
                .attr("class", "tooltip-interpretation")
                .attr("x", 15)
                .attr("y", 40)
                .attr("fill", "#041F3D")
                .style("font-size", "18px")
                .style("font-family", "'Baloo 2', Comic Sans MS, Arial");

            // Hover-over events
            lollipopGroups.on("mouseover", function (event, d) {
                const borderColor = colorScale(d.bite_versus_population_ratio);
                d3.select(this).select(".lollipop-circle")
                    .attr("r", 15)
                    .attr("stroke-width", 4);

                d3.select(this).select(".lollipop-line")
                    .attr("stroke-width", 4);

                ageTooltip.select("rect")
                    .attr("stroke", borderColor);

                const ratio = d.bite_versus_population_ratio.toFixed(2);
                const comparison = d.bite_versus_population_ratio > 1 ? "higher" : "lower";

                const htmlContent = `At the age of <tspan style="font-weight:bold">${d.age === 1 ? "1 year or younger" : `${d.age} years`}</tspan>, the bite rate is <tspan style="font-weight:bold">${ratio}</tspan> times <tspan style="font-weight:bold">${comparison}</tspan> than expected based on population share.`;

                // text wrapping
                const tooltipText = ageTooltip.select(".tooltip-interpretation");
                tooltipText.selectAll("*").remove();

                const maxCharsPerLine = 40;
                const words = htmlContent.split(' ');
                let line = [];
                let lineNumber = 0;
                const xPos = 15;
                const initialYPos = 30;
                const lineHeight = 23;

                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontFamily = "'Baloo 2', Comic Sans MS, Arial";
                tempDiv.style.fontSize = '18px';
                document.body.appendChild(tempDiv);

                words.forEach((word, i) => {
                    line.push(word);
                    tempDiv.innerHTML = line.join(' ');
                    const testWidth = tempDiv.offsetWidth;

                    if (testWidth > 340 && line.length > 1) {
                        line.pop();
                        tooltipText.append("tspan")
                            .attr("x", xPos)
                            .attr("y", initialYPos + (lineNumber * lineHeight))
                            .html(line.join(' '));

                        line = [word];
                        lineNumber++;
                    }
                });

                // Add the last line
                if (line.length > 0) {
                    tooltipText.append("tspan")
                        .attr("x", xPos)
                        .attr("y", initialYPos + (lineNumber * lineHeight))
                        .html(line.join(' '));
                }

                document.body.removeChild(tempDiv);

                const [mouseX, mouseY] = d3.pointer(event, svg_age.node());
                const tooltipWidth = 350;
                const tooltipHeight = +ageTooltip.select("rect").attr("height");
                const padding = 10;

                let x = mouseX + tooltipWidth + padding > width_age
                    ? Math.max(padding, mouseX - tooltipWidth - padding)
                    : Math.max(padding, mouseX + padding);

                let y = mouseY + tooltipHeight + padding > height_age
                    ? Math.max(padding, mouseY - tooltipHeight - padding)
                    : Math.max(padding, mouseY + padding);

                y = Math.max(padding, y);

                ageTooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y - 40})`);
            })
                .on("mouseout", function () {
                    d3.select(this).select(".lollipop-circle")
                        .attr("r", 10)
                        .attr("stroke-width", 2);

                    d3.select(this).select(".lollipop-line")
                        .attr("stroke-width", 2);

                    ageTooltip.style("opacity", 0);
                })
                .on("mousemove", function (event) {
                    const [mouseX, mouseY] = d3.pointer(event, svg_age.node());
                    const tooltipWidth = 350;
                    const tooltipHeight = +ageTooltip.select("rect").attr("height");
                    const padding = 10;

                    let x = mouseX + tooltipWidth + padding > width_age
                        ? Math.max(padding, mouseX - tooltipWidth - padding)
                        : Math.max(padding, mouseX + padding);

                    let y = mouseY + tooltipHeight + padding > height_age
                        ? Math.max(padding, mouseY - tooltipHeight - padding)
                        : Math.max(padding, mouseY + padding);

                    ageTooltip.attr("transform", `translate(${x},${y - 40})`);
                })

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------


            // Chart 4: Bite incidents by time
            const timeData = await d3.csv("time_df.csv");
            console.log(timeData);

            const monthlyTotals = {};

            timeData.forEach(d => {
                const key = `${String(d.month).padStart(2, '0')}-${d.year}`;
                const bites = +d.number_of_bites;
                const temp = +d.temperature_avg;
                const precip = +d.precipitation;

                if (!monthlyTotals[key]) {
                    monthlyTotals[key] = {
                        monthYear: key,
                        year: +d.year,
                        month: +d.month,
                        totalBites: 0,
                        tempSum: 0,
                        precipitation: 0,
                        dayCount: 0
                    };
                }
                monthlyTotals[key].totalBites += bites;
                monthlyTotals[key].tempSum += temp;
                monthlyTotals[key].dayCount += 1;
                monthlyTotals[key].precipitation += precip;
            });

            const monthlyData = Object.values(monthlyTotals).map(d => {
                return {
                    monthYear: d.monthYear,
                    year: d.year,
                    month: d.month,
                    totalBites: d.totalBites,
                    avgTemp: d.tempSum / d.dayCount,
                    avgPrecip: d.precipitation / d.dayCount,
                };
            }).sort((a, b) => a.year - b.year || a.month - b.month);

            console.log(monthlyData);

            // ---------- TIME CHART ----------
            const svg_time = d3.select("#svg-time");
            const width_time = +svg_time.attr("width");
            const height_time = +svg_time.attr("height");
            const margin_time = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_time = width_time - margin_time.left - margin_time.right;
            const chartHeight_time = height_time - margin_time.top - margin_time.bottom;

            const g_time = svg_time.append("g")
                .attr("transform", `translate(${margin_time.left},${margin_time.top})`);

            const xScale_time = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_time]);

            const yScale_time = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.totalBites))
                .range([chartHeight_time, 0]);

            const time_bite_line = d3.line()
                .x((d, i) => xScale_time(i))
                .y(d => yScale_time(d.totalBites));

            g_time.append("path")
                .attr("fill", "none")
                .attr("stroke", "#FD8C40")
                .attr("stroke-width", 2)
                .attr("d", time_bite_line(monthlyData));

            // Create x-axis with classed group so we can update it later
            const xAxis_time = d3.axisBottom(xScale_time)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

            g_time.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartHeight_time})`)
                .call(xAxis_time)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            const yAxis_time = d3.axisLeft(yScale_time);
            g_time.append("g").call(yAxis_time);

            svg_time.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 12)
                .attr("x", -height_time / 2 + 30)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .text("Number of Bites");

            svg_time.append("text")
                .attr("x", margin_time.left + chartWidth_time / 2)
                .attr("y", height_time - 5)
                .style("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .text("Time (Month-Year)");


            // ---------- TEMP CHART ----------
            const svg_temp = d3.select("#svg-temp");
            const width_temp = +svg_temp.attr("width");
            const height_temp = +svg_temp.attr("height");
            const margin_temp = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_temp = width_temp - margin_temp.left - margin_temp.right;
            const chartHeight_temp = height_temp - margin_temp.top - margin_temp.bottom;

            const g_temp = svg_temp.append("g")
                .attr("transform", `translate(${margin_temp.left},${margin_temp.top})`);

            const xScale_temp = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_temp]);

            const yScale_temp = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.avgTemp))
                .range([chartHeight_temp, 0]);

            const time_temp_line = d3.line()
                .x((d, i) => xScale_temp(i))
                .y(d => yScale_temp(d.avgTemp));

            g_temp.append("path")
                .attr("fill", "none")
                .attr("stroke", "#F4D35E")
                .attr("stroke-width", 2)
                .attr("d", time_temp_line(monthlyData));

            const xAxis_temp = d3.axisBottom(xScale_temp)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

            g_temp.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartHeight_temp})`)
                .call(xAxis_temp)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            const yAxis_temp = d3.axisLeft(yScale_temp);
            g_temp.append("g").call(yAxis_temp);

            svg_temp.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_temp / 2 + 30)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "13px")
                .style("font-weight", "bold")
                .text("Average Temperature(F)");


            svg_temp.append("text")
                .attr("x", margin_temp.left + chartWidth_temp / 2)
                .attr("y", height_temp - 5)
                .style("text-anchor", "middle")
                .style("font-size", "13px")
                .style("font-weight", "bold")
                .text("Time (Month-Year)");


            // ---------- PRECIP CHART ----------
            const svg_precip = d3.select("#svg-precip");
            const width_precip = +svg_precip.attr("width");
            const height_precip = +svg_precip.attr("height");
            const margin_precip = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_precip = width_precip - margin_precip.left - margin_precip.right;
            const chartHeight_precip = height_precip - margin_precip.top - margin_precip.bottom;

            const g_precip = svg_precip.append("g")
                .attr("transform", `translate(${margin_precip.left},${margin_precip.top})`);

            const xScale_precip = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_precip]);

            const yScale_precip = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.avgPrecip))
                .range([chartHeight_precip, 0]);

            const time_precip_line = d3.line()
                .x((d, i) => xScale_precip(i))
                .y(d => yScale_precip(d.avgPrecip));

            g_precip.append("path")
                .attr("fill", "none")
                .attr("stroke", "#3ec9c1")
                .attr("stroke-width", 2)
                .attr("d", time_precip_line(monthlyData));

            const xAxis_precip = d3.axisBottom(xScale_precip)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

            g_precip.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartHeight_precip})`)
                .call(xAxis_precip)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            const yAxis_precip = d3.axisLeft(yScale_precip);
            g_precip.append("g").call(yAxis_precip);

            svg_precip.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_precip / 2 + 30)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "13px")
                .style("font-weight", "bold")
                .text("Average Precipitation");

            svg_precip.append("text")
                .attr("x", margin_precip.left + chartWidth_precip / 2)
                .attr("y", height_precip - 5)
                .style("text-anchor", "middle")
                .style("font-size", "13px")
                .style("font-weight", "bold")
                .text("Time (Month-Year)");


            const allSVGs = [
                {
                    svg: svg_time,
                    g: g_time,
                    xScale: xScale_time,
                    yScale: yScale_time,
                    dataKey: "totalBites",
                    label: "Bites",
                    color: "#FD8C40",
                    height: chartHeight_time,
                    chartWidth: chartWidth_time
                },
                {
                    svg: svg_temp,
                    g: g_temp,
                    xScale: xScale_temp,
                    yScale: yScale_temp,
                    dataKey: "avgTemp",
                    label: "Avg Temp (°F)",
                    color: "#F4D35E",
                    height: chartHeight_temp,
                    chartWidth: chartWidth_temp
                },
                {
                    svg: svg_precip,
                    g: g_precip,
                    xScale: xScale_precip,
                    yScale: yScale_precip,
                    dataKey: "avgPrecip",
                    label: "Avg Precip",
                    color: "#3ec9c1",
                    height: chartHeight_precip,
                    chartWidth: chartWidth_precip
                }
            ];

            // Append vlines, circles and groups
            allSVGs.forEach(({ g, height, color }) => {
                g.append("line")
                    .attr("class", "vline")
                    .attr("y1", 0)
                    .attr("y2", height)
                    .attr("stroke", "gray")
                    .attr("stroke-dasharray", "4")
                    .style("opacity", 0);

                g.append("circle")
                    .attr("class", "hover-circle")
                    .attr("r", 5)
                    .attr("fill", color)
                    .attr("stroke", "black")
                    .attr("stroke-width", 2)
                    .style("opacity", 0);

                const tooltipGroup = g.append("g")
                    .attr("class", "tooltip-group")
                    .style("display", "none");

                tooltipGroup.append("rect")
                    .attr("class", "tooltip-box")
                    .attr("fill", "white")
                    .attr("stroke", color)
                    .attr("stroke-width", 2)
                    .attr("rx", 6)
                    .attr("ry", 6)
                    .attr("width", 140)
                    .attr("height", 45);

                tooltipGroup.append("text")
                    .attr("class", "tooltip-label")
                    .attr("x", 10)
                    .attr("y", 20)
                    .attr("font-size", 12)
                    .attr("fill", "#000");

                tooltipGroup.append("text")
                    .attr("class", "tooltip-value")
                    .attr("x", 10)
                    .attr("y", 35)
                    .attr("font-size", 12)
                    .attr("font-weight", "bold")
                    .attr("fill", "#000");
            });

            // Add shared brush
            const brush = d3.brushX()
                .on("end", brushed);

 
            allSVGs.forEach(({ g, chartWidth, height }) => {
                g.append("g")
                    .attr("class", "brush")
                    .call(
                        brush.extent([[0, 0], [chartWidth, height]])
                    );
            });

            let currentData = monthlyData;
            let dataOffset = 0; 

            //initial hover
            allSVGs.forEach(({ svg, xScale, yScale, g, dataKey, label, color, chartWidth }) => {
                svg.on("mousemove", function (event) {
                    const [mouseX] = d3.pointer(event);
                    const chartX = mouseX - 70; // margin.left
                    const index = Math.round(xScale.invert(chartX));

                    if (index >= 0 && index < currentData.length) {
                        const actualIndex = index + dataOffset;
                        const data = monthlyData[actualIndex];

                        allSVGs.forEach(({ g, xScale, yScale, dataKey, label, color, chartWidth }) => {
                            const x = xScale(index);
                            const y = yScale(data[dataKey]);

                            g.select(".vline")
                                .attr("x1", x)
                                .attr("x2", x)
                                .style("opacity", 1);

                            g.select(".hover-circle")
                                .attr("cx", x)
                                .attr("cy", y)
                                .style("opacity", 1);

                            const tooltipWidth = 140;
                            const tooltipHeight = 45;
                            const padding = 10;

                            let tooltipX = x + padding;
                            let tooltipY = y - tooltipHeight - padding;

                            if (x + tooltipWidth + padding > chartWidth) {
                                tooltipX = x - tooltipWidth - padding;
                            }
                            if (tooltipY < 0) {
                                tooltipY = y + padding;
                            }

                            const tooltipGroup = g.select(".tooltip-group")
                                .attr("transform", `translate(${tooltipX},${tooltipY})`)
                                .style("display", "block");

                            tooltipGroup.select(".tooltip-label")
                                .text(`${data.monthYear}`);

                            tooltipGroup.select(".tooltip-value")
                                .text(`${label}: ${data[dataKey].toFixed(2)}`);

                            tooltipGroup.select(".tooltip-box")
                                .attr("stroke", color);
                        });
                    }
                });

                svg.on("mouseleave", function () {
                    allSVGs.forEach(({ g }) => {
                        g.select(".vline").style("opacity", 0);
                        g.select(".hover-circle").style("opacity", 0);
                        g.select(".tooltip-group").style("display", "none");
                    });
                });
            });

        
            function brushed(event) {
                if (!event.selection) return;

                // Brush selection coordinates
                const [x0, x1] = event.selection;

            
                const index0 = Math.max(0, Math.floor(xScale_time.invert(x0)));
                const index1 = Math.min(monthlyData.length - 1, Math.ceil(xScale_time.invert(x1)));

                
                const brushedData = monthlyData.slice(index0, index1 + 1);
                currentData = brushedData;
                dataOffset = index0;

                // Update all charts
                allSVGs.forEach((chart) => {
                    const { xScale, yScale, g, dataKey, chartWidth, height } = chart;

                    
                    xScale.domain([0, brushedData.length - 1]);

                    
                    const updatedLine = d3.line()
                        .x((d, i) => xScale(i))
                        .y(d => yScale(d[dataKey]));

                    g.select("path")
                        .datum(brushedData)
                        .attr("d", updatedLine);

                    
                    let tickValues;
                    let tickFormat;

                    if (brushedData.length <= 10) {
                        
                        tickValues = d3.range(0, brushedData.length);
                        tickFormat = i => brushedData[i]?.monthYear;
                    } else {
                        
                        const step = Math.ceil(brushedData.length / 10);
                        tickValues = d3.range(0, brushedData.length, step);

                        
                        if (!tickValues.includes(0)) tickValues.unshift(0);
                        if (!tickValues.includes(brushedData.length - 1))
                            tickValues.push(brushedData.length - 1);

                        tickFormat = i => brushedData[i]?.monthYear;
                    }

                    const axis = d3.axisBottom(xScale)
                        .tickValues(tickValues)
                        .tickFormat(tickFormat);

                    
                    g.select(".x-axis")
                        .transition()
                        .duration(300)
                        .call(axis);

                    
                    g.select(".x-axis").selectAll("text")
                        .attr("transform", "rotate(45)")
                        .style("text-anchor", "start");

                    
                    g.select(".brush").call(brush.move, null);
                });
            }


            
            const timeContainer = d3.select("#container-time");

            
            const timeDescriptionDiv = timeContainer.select('div.time-description');
            timeContainer.style("position", "relative");

            const resetButton = timeContainer
                .insert("button", "div")
                .attr("id", "reset-brush-button")
                .attr("class", "reset-button")
                .style("position", "absolute")
                .style("top", "520px")
                .style("right", "45%")
                .style("padding", "10px 30px")
                .style("background-color", "lightgray")
                .style("border", "2px solid #000000")
                .style("border-radius", "30px")
                .style("cursor", "pointer")
                .style("font-size", "14px")
                .text("Reset Zoom")
                .on("click", resetBrush);


            function resetBrush() {
                currentData = monthlyData;
                dataOffset = 0;

                allSVGs.forEach((chart) => {
                    const { xScale, yScale, g, dataKey, chartWidth, height } = chart;

                    xScale.domain([0, monthlyData.length - 1]);

                    const updatedLine = d3.line()
                        .x((d, i) => xScale(i))
                        .y(d => yScale(d[dataKey]));

                    g.select("path")
                        .datum(monthlyData)
                        .attr("d", updatedLine);

                    const axis = d3.axisBottom(xScale)
                        .ticks(monthlyData.length)
                        .tickFormat((d, i) => i % 12 === 0 ? monthlyData[i].monthYear : '');

                    g.select(".x-axis")
                        .transition()
                        .duration(300)
                        .call(axis);

                    g.select(".x-axis").selectAll("text")
                        .attr("transform", "rotate(45)")
                        .style("text-anchor", "start");

                    g.select(".brush").call(brush.move, null);
                });
            }

            resetButton.on("mouseover", function () {
                d3.select(this)
                    .style("background-color", "#F09253")
            })
                .on("mouseout", function () {
                    d3.select(this)
                        .style("background-color", "lightgray")
                });
        }
        requestData();
    </script>

    <script>

        const imageFilenames = [
            "American_Bulldog.png",
            "Australian_Shepherd.png",
            "Beagle.png",
            "Bernese_Mountain_Dog.png",
            "Boston_Terrier.png",
            "Boxer.png",
            "Cane_Corso.png",
            "Doberman_Pinscher.png",
            "French_Bulldog.png",
            "German_Shepherd.png",
            "German_Shorthaired_Pointer.png",
            "Golden_Retriever.png",
            "Great_Dane.png",
            "Labrador_Retriever.png",
            "Pembroke_Welsh_Corgi.png",
            "Rottweiler.png",
            "Siberian_Husky.png"
        ];

        // Map framework
        mapboxgl.accessToken = 'pk.eyJ1Ijoia3g2NCIsImEiOiJjbGkzd2E1dmsxMzNoM2twY2p2azF0bGVlIn0.t_v73kaAMUtoGBPESpw3uA';

        const map = new mapboxgl.Map({
            container: 'mapCanvas',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [-74.006, 40.7128],
            zoom: 9
        });

        map.dragRotate.disable();
        map.touchZoomRotate.disableRotation();

        const geocoder = new MapboxGeocoder({
            accessToken: mapboxgl.accessToken,
            mapboxgl: mapboxgl,
            marker: true,
            placeholder: "Search...",
            zoom: 14
        });

        document.getElementById('geocoder-container').appendChild(geocoder.onAdd(map));

        let jsonData = null;
        let selectMode = false;
        let marker = null;

        map.on("click", (e) => {
            if (!selectMode) return;

            const { lng, lat } = e.lngLat;

            if (marker) {
                marker.setLngLat([lng, lat]);
            } else {
                marker = new mapboxgl.Marker()
                    .setLngLat([lng, lat])
                    .addTo(map);
            }

            map.flyTo({ center: [lng, lat], zoom: 15 });

            document.getElementById("location-info").innerText = `Selected Location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;

            selectMode = false;
        });

        let zipCentroidGeoJSON = null;


        // Load the  files
        Promise.all([
            d3.csv("zip_df.csv"),
            d3.json("nyc_zip_codes_with_centroids.geojson"),
            d3.json("nyc_open_space.geojson")
        ]).then(([zipData, zipGeoJSON, parkGeoJSON]) => {

            const biteByZip = {};
            const dogsByZip = {};

            zipData.forEach(d => {
                biteByZip[d.zip_code] = +d.number_of_bites;
                dogsByZip[d.zip_code] = +d.number_of_dogs;
                d.top_biter_by_bite_ratio = d.top_biter_by_bite_ratio?.trim();
            });

            const zipCentroidFeatures = [];

            zipGeoJSON.features.forEach(f => {
                const zip = f.properties.postcode || f.properties.ZIPCODE || f.properties.zip || f.properties.postalCode;
                const record = zipData.find(d => d.zip_code === zip);
                const numBites = biteByZip[zip] || 0;
                const numDogs = dogsByZip[zip] || 0;
                const topBiter = record?.top_biter_by_bite_ratio || null;
                f.properties.number_of_bites = numBites;
                f.properties.number_of_dogs = numDogs;

                if (f.properties.centroid_lon && f.properties.centroid_lat) {
                    zipCentroidFeatures.push({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [f.properties.centroid_lon, f.properties.centroid_lat]
                        },
                        properties: {
                            zip: zip,
                            number_of_bites: numBites,
                            number_of_dogs: numDogs,
                            top_biter_by_bite_ratio: topBiter
                        }
                    });
                }
            });

            zipCentroidGeoJSON = {
                type: 'FeatureCollection',
                features: zipCentroidFeatures
            };

            console.log("Number of ZIP dots created:", zipCentroidFeatures.length);

            map.on("load", () => {


                // ---- Parks layer ----
                map.addSource('parks', {
                    type: 'geojson',
                    data: parkGeoJSON
                });

                map.addLayer({
                    'id': 'park-fills',
                    'type': 'fill',
                    'source': 'parks',
                    'paint': {
                        'fill-color': '#72c27e',
                        'fill-opacity': 0.6
                    }
                });

                // map.addLayer({
                //     'id': 'park-borders',
                //     'type': 'line',
                //     'source': 'parks',
                //     'paint': {
                //         'line-color': '#2e8b57',
                //         'line-width': 1
                //     }
                // });

                const parkPopup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: false
                });

                map.on('mouseenter', 'park-fills', (e) => {
                    map.getCanvas().style.cursor = 'pointer';
                    const parkName = e.features[0].properties.PARK_NAME || "Unnamed Park";
                    const coordinates = e.lngLat;

                    parkPopup
                        .setLngLat(coordinates)
                        .setHTML(`<strong>${parkName}</strong>`)
                        .addTo(map);
                });

                map.on('mouseleave', 'park-fills', () => {
                    map.getCanvas().style.cursor = '';
                    parkPopup.remove();
                });


                // ---- ZIP shape layer ---
                map.addSource('zipcodes', {
                    type: 'geojson',
                    data: zipGeoJSON
                });

                map.addLayer({
                    'id': 'zip-dog-fills',
                    'type': 'fill',
                    'source': 'zipcodes',
                    'paint': {
                        'fill-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'number_of_dogs'],
                            0, '#ffffcc',
                            500, '#a1dab4',
                            2000, '#41b6c4',
                            4000, '#2c7fb8',
                            6000, '#08306b'
                        ],
                        'fill-opacity': 0.3

                    }
                });




                // ---- ZIP centroid dots ----
                map.addSource('zip-centroids', {
                    type: 'geojson',
                    data: zipCentroidGeoJSON
                });

                map.addLayer({
                    'id': 'zip-centroid-dots',
                    'type': 'circle',
                    'source': 'zip-centroids',
                    'paint': {
                        'circle-radius': [
                            'interpolate',
                            ['linear'],
                            ['get', 'number_of_bites'],
                            0, 2,
                            250, 6,
                            500, 12,
                            750, 18
                        ],
                        'circle-color': [
                            'interpolate',
                            ['linear'],
                            ['get', 'number_of_bites'],
                            0, '#ffe082',
                            50, '#feb24c',
                            200, '#fd8d3c',
                            400, '#f03b20',
                            600, '#bd0026'
                        ],
                        'circle-opacity': 0.7
                        ,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-width': .5
                    }
                });

                //                 map.addLayer({
                //   id: 'zip-bite-heatmap',
                //   type: 'heatmap',
                //   source: 'zip-centroids',
                //   maxzoom: 15,
                //   paint: {
                //     'heatmap-weight': [
                //       'interpolate',
                //       ['linear'],
                //       ['get', 'number_of_bites'],
                //       0, 0,
                //       500, 1
                //     ],
                //     'heatmap-intensity': 5,
                //     'heatmap-radius': [
                //       'interpolate',
                //       ['linear'],
                //       ['zoom'],
                //       10, 25,
                //       15, 50
                //     ],
                //     'heatmap-opacity': 0.4,
                //     'heatmap-color': [
                //       'interpolate',
                //       ['linear'],
                //       ['heatmap-density'],
                //       0, 'rgba(255,255,255,0)',
                //       0.2, 'rgba(255,237,160,0.8)',
                //       0.4, 'rgba(254,178,76,0.8)',
                //       0.6, 'rgba(253,141,60,0.9)',
                //       0.8, 'rgba(240,59,32,0.9)',
                //       1, 'rgba(189,0,38,0.95)'
                //     ]
                //   }
                // });

                // map.setLayoutProperty('zip-centroid-dots', 'visibility', 'none');




                // ---- ZIP dot hover popup ----
                const zipPopup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: false
                });

                map.on('mouseenter', 'zip-centroid-dots', (e) => {
                    map.getCanvas().style.cursor = 'pointer';
                    const props = e.features[0].properties;
                    const coordinates = e.lngLat;

                    zipPopup
                        .setLngLat(coordinates)
                        .setHTML(`<strong>ZIP: ${props.zip}</strong><br>Bites: ${props.number_of_bites}<br>Dogs: ${props.number_of_dogs}`)

                        .addTo(map);
                });

                map.on('mouseleave', 'zip-centroid-dots', () => {
                    map.getCanvas().style.cursor = '';
                    zipPopup.remove();
                });

                map.addSource('breed-icon-source', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: []
                    }
                });

                map.addLayer({
                    id: 'breed-icon-layer',
                    type: 'symbol',
                    source: 'breed-icon-source',
                    layout: {
                        'icon-image': ['get', 'icon'],
                        'icon-size': 0.05,
                        'icon-allow-overlap': true
                    }
                });



                imageFilenames.forEach(filename => {
                    const name = filename.replace('.png', '');
                    map.loadImage(`images/${filename}`, (error, image) => {
                        if (error) return console.error(`Image ${filename} failed to load:`, error);
                        if (!map.hasImage(name)) {
                            map.addImage(name, image);
                        }
                    });
                });



            });

        });


        function toggleLayer(checkbox, layerBaseId) {
            const layerIds = [layerBaseId];

            if (layerBaseId.includes('fills')) {
                layerIds.push(layerBaseId.replace('fills', 'borders'));
            }

            layerIds.forEach(layer => {
                if (!map.getLayer(layer)) return;
                map.setLayoutProperty(layer, 'visibility', checkbox.checked ? 'visible' : 'none');
            });
        }

        function createLegend({ label, layerId, colors, thresholds }) {
            const container = document.getElementById("layer-buttons");

            const checkboxLabel = document.createElement("label");
            checkboxLabel.innerHTML = `<input type="checkbox" onchange="toggleLayer(this, '${layerId}')" checked> ${label}`;
            container.appendChild(checkboxLabel);

            const legendWrapper = document.createElement("div");
            legendWrapper.className = "discrete-legend";

            const legendBar = document.createElement("div");
            legendBar.className = "legend-bar";
            colors.forEach(color => {
                const step = document.createElement("div");
                step.className = "legend-step";
                step.style.background = color;
                legendBar.appendChild(step);
            });
            legendWrapper.appendChild(legendBar);

            const labelRow = document.createElement("div");
            labelRow.className = "legend-labels";
            thresholds.forEach(value => {
                const span = document.createElement("span");
                span.textContent = value;
                labelRow.appendChild(span);
            });
            legendWrapper.appendChild(labelRow);

            container.appendChild(legendWrapper);
        }


        createLegend({
            label: "Bite Incidents",
            layerId: "zip-centroid-dots",
            colors: ["#ffe082", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
            thresholds: ["0", "50", "200", "400", "600+"]
        });



        createLegend({
            label: "Dog Population Distribution",
            layerId: "zip-dog-fills",
            colors: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#08306b"],
            thresholds: ["0", "500", "2000", "4000", "6000+"]
        });


        createLegend({
            label: "Open Spaces / Parks",
            layerId: "park-fills",
            colors: ["#ffffff", "#72c27e"],
            thresholds: ["Other Areas", "Open Spaces / Parks"]
        });


        let activeBreed = null;

        function updateBreedIconLayer(breed) {
            if (activeBreed === breed) {
                map.getSource('breed-icon-source').setData({
                    type: 'FeatureCollection',
                    features: []
                });
                activeBreed = null;
                return;
            }

            activeBreed = breed;

            const filteredFeatures = zipCentroidGeoJSON.features.filter(f =>
                f.properties.top_biter_by_bite_ratio === breed
            ).map(f => ({
                type: 'Feature',
                geometry: f.geometry,
                properties: {
                    icon: breed.replace(/ /g, '_')
                }
            }));

            map.getSource('breed-icon-source').setData({
                type: 'FeatureCollection',
                features: filteredFeatures
            });
        }

        const grid = document.getElementById('image-button-grid');


        imageFilenames.forEach(filename => {
            const iconId = filename.replace('.png', '');
            map.loadImage(`images/${filename}`, (error, image) => {
                if (error) {
                    console.warn(`Could not load image ${filename}:`, error);
                    return;
                }
                if (!map.hasImage(iconId)) {
                    map.addImage(iconId, image);
                }
            });
        });

        imageFilenames.forEach(filename => {
            const breedName = filename.replace('.png', '').replace(/_/g, ' ');

            const btn = document.createElement('button');
            btn.style.display = 'flex';
            btn.style.flexDirection = 'column';
            btn.style.alignItems = 'center';
            btn.style.padding = '0';

            const img = document.createElement('img');
            img.src = `images/${filename}`;
            img.alt = breedName;

            const label = document.createElement('span');
            label.textContent = breedName;
            label.style.fontSize = '12px';
            label.style.marginTop = '4px';
            label.style.color = '#041F3D';
            label.style.textAlign = 'center';

            btn.appendChild(img);
            btn.appendChild(label);
            btn.onclick = () => updateBreedIconLayer(breedName);
            grid.appendChild(btn);
        });




    </script>



</body>