<html>

<head>

    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script
        src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.min.js"></script>
    <link rel="stylesheet"
        href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        body {
            margin: 0px;
            font-family: 'Baloo 2', cursive;
            color: #041F3D;
            display: flex;
            flex-direction: column;
        }

        .container-centered {
            width: 96%;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
        }

        h2 {
            font-size: 28px;
            font-weight: 700;
        }

        .colored-bg {
            background-color: #ffefda
        }

        .session {
            padding-top: 40px;
            padding-bottom: 40px;
        }

    .map-container {
        position: relative;
        width: 100%;
        height: 100vh;
    }

    #mapCanvas {
        width: 100%;
        height: 100%;
    }

    #geocoder-container {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 300px;
        z-index: 2;
    }

    .sidebar {
        position: absolute;
        top: 80px;
        right: 20px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        padding: 12px 16px;
        z-index: 2;
    }

    .sidebar button {
        display: block;
        width: 180px;
        margin: 8px 0;
        padding: 10px 14px;
        background-color: #4285f4;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 15px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .sidebar button:hover {
        background-color: #3367d6;
    }

    .sidebar button:active {
        background-color: #254ba0;
    }
</style>


        #geocoder-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 50%;
            z-index: 1;
        }
    </style>


</head>

<body>

    <!--Introduction-->
    <div class="session container-centered">
        <div>
            <h1 style="font-weight:800; font-size: 32px;">
                TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE
            </h1>
            <h3>Flavia Jiang, Curtis Xu, Xinyi Zhou</h3>

            <div>Intro paragraph</div>
        </div>
    </div>

    <!--Bite incidents by breed-->
    <div class="session colored-bg">
        <div id="container-breed" class="container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>
            <svg id="svg-breed" height="600" width="1100"></svg>
        </div>
    </div>

    <!--Bite incidents by gender x spay & neuter-->
    <div class="session">
        <div id="container-gender" class="container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>

        </div>
    </div>

    <!--Bite incidents by age-->
    <div class="session colored-bg">
        <div id="container-age" class="colored-bg container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>

        </div>
    </div>

    <!--Bite incidents by time-->
    <div class="session">
        <div id="container-time" class="container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>
            <svg id="svg-time" height="400" width="700"></svg>

        </div>
    </div>

    <!--Bite incidents by neighborhood-->
    <div class="session colored-bg">
        <div id="container-zip" class="colored-bg container-centered">
            <h2>Interactive Map </h2>

        </div>

        <div class="map-container">
            <div id="mapCanvas"></div>
            <div id="geocoder-container"></div>
            <div id="layer-control" class="sidebar">
                <button onclick="toggleLayer('zip-centroid-dots')">Dog Bites</button><br>
                <button onclick="toggleLayer('zip-dog-fills')">Dog Distribution</button><br>
                <button onclick="toggleLayer('park-fills')">Open Spaces / Parks</button>
                
            </div>
       
        </div>


    </div>



    <script>
        const requestData = async () => {
            // Bite incidents by breed
            const breedData = await d3.csv("breed_df.csv");

            breedData.forEach(d => {
                d.bite_score_ranking = 16 - +d.bite_score_ranking;
                d.aggresiveness_score_ranking = 16 - +d.aggresiveness_score_ranking;
            });

            const svg_breed = d3.select("#svg-breed");
            const width_breed = +svg_breed.attr("width");
            const height_breed = +svg_breed.attr("height");
            const margin_breed = { top: 30, right: 20, bottom: 100, left: 60 };
            const chartWidth_breed = width_breed - margin_breed.left - margin_breed.right;
            const chartHeight_breed = height_breed - margin_breed.top - margin_breed.bottom;

            const g_breed = svg_breed.append("g")
                .attr("transform", `translate(${margin_breed.left},${margin_breed.top})`);

            const xScale_breed = d3.scaleBand()
                .domain(breedData.map(d => d.breed))
                .range([0, chartWidth_breed])
                .padding(0.4);

            const yScale_breed = d3.scaleLinear()
                .domain([0, 15])
                .range([chartHeight_breed / 2, 0]);

            const yScale_breed_neg = d3.scaleLinear()
                .domain([0, 15])
                .range([0, chartHeight_breed / 2]);

            g_breed.selectAll(".bar-bite")
                .data(breedData)
                .join("rect")
                .attr("class", "bar-bite")
                .attr("x", d => xScale_breed(d.breed))
                .attr("width", xScale_breed.bandwidth())
                .attr("y", d => yScale_breed(d.bite_score_ranking))
                .attr("height", d => chartHeight_breed / 2 - yScale_breed(d.bite_score_ranking))
                .attr("fill", "#ff8c42");

            g_breed.selectAll(".bar-agg")
                .data(breedData)
                .join("rect")
                .attr("class", "bar-agg")
                .attr("x", d => xScale_breed(d.breed))
                .attr("width", xScale_breed.bandwidth())
                .attr("y", chartHeight_breed / 2)
                .attr("height", d => yScale_breed_neg(d.aggresiveness_score_ranking))
                .attr("fill", "#041f3d");

            g_breed.selectAll(".breed-image")
                .data(breedData)
                .join("circle")
                .attr("cx", d => xScale_breed(d.breed) + xScale_breed.bandwidth() / 2)
                .attr("cy", chartHeight_breed / 2)
                .attr("r", xScale_breed.bandwidth() * 0.7)
                .attr("fill", "white")
                .attr("stroke", "#041f3d")
                .attr("stroke-width", 2);

            g_breed.selectAll(".breed-img")
                .data(breedData)
                .join("image")
                .attr("xlink:href", d => `dog_cartoons/${d.breed.replaceAll(' ', '_')}.png`)
                .attr("x", d => xScale_breed(d.breed) - xScale_breed.bandwidth() * 0.1)
                .attr("y", chartHeight_breed / 2 - xScale_breed.bandwidth() * 0.6)
                .attr("width", xScale_breed.bandwidth() * 1.2)
                .attr("height", xScale_breed.bandwidth() * 1.2);


            const yAxis_breed = d3.axisLeft(yScale_breed)
                .tickValues([0, 3, 6, 9, 12, 15]);
            g_breed.append("g").call(yAxis_breed);

            const yAxis_breed_neg = d3.axisLeft(yScale_breed_neg)
                .tickValues([0, 3, 6, 9, 12, 15]);
            g_breed.append("g")
                .attr("transform", `translate(0,${chartHeight_breed / 2})`)
                .call(yAxis_breed_neg);


            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------


            // Bite incidents by time
            const timeData = await d3.csv("time_df.csv");

            const monthlyTotals = {};

            timeData.forEach(d => {
                const key = `${String(d.month).padStart(2, '0')}-${d.year}`;
                const bites = +d.number_of_bites;
                const temp = +d.temperature_avg;

                if (!monthlyTotals[key]) {
                    monthlyTotals[key] = {
                        monthYear: key,
                        year: +d.year,
                        month: +d.month,
                        totalBites: 0,
                        tempSum: 0,
                        dayCount: 0
                    };
                }
                monthlyTotals[key].totalBites += bites;
                monthlyTotals[key].tempSum += temp;
                monthlyTotals[key].dayCount += 1;
            });

            const monthlyData = Object.values(monthlyTotals).map(d => {
                return {
                    monthYear: d.monthYear,
                    year: d.year,
                    month: d.month,
                    totalBites: d.totalBites,
                    avgTemp: d.tempSum / d.dayCount
                };
            }).sort((a, b) => a.year - b.year || a.month - b.month);

            const svg_time = d3.select("#svg-time");
            const width_time = +svg_time.attr("width");
            const height_time = +svg_time.attr("height");
            const margin_time = { top: 10, right: 10, bottom: 50, left: 50 };
            const chartWidth_time = width_time - margin_time.left - margin_time.right;
            const chartHeight_time = height_time - margin_time.top - margin_time.bottom;

            const g_time = svg_time.append("g")
                .attr("transform", `translate(${margin_time.left},${margin_time.top})`);

            const xScale_time = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_time]);

            const yScale_time = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.totalBites))
                .range([chartHeight_time, 0]);

            const time_bite_line = d3.line()
                .x((d, i) => xScale_time(i))
                .y(d => yScale_time(d.totalBites));

            g_time.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 2)
                .attr("d", time_bite_line);


            // const xAxis_time = d3.axisBottom(xScale_time)
            //     .ticks(monthlyData.length)
            //     .tickFormat((d, i) => monthlyData[i].monthYear);


            const xAxis_time = d3.axisBottom(xScale_time)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => {
                    if (i % 12 === 0) {
                        return monthlyData[i].monthYear;
                    }
                    return '';
                });

            g_time.append("g")
                .attr("transform", `translate(0,${chartHeight_time})`)
                .call(xAxis_time)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            // Y-axis
            const yAxis_time = d3.axisLeft(yScale_time);
            g_time.append("g").call(yAxis_time);
        }

        requestData();
    </script>

<script>
    // Map framework
    mapboxgl.accessToken = 'pk.eyJ1Ijoia3g2NCIsImEiOiJjbGkzd2E1dmsxMzNoM2twY2p2azF0bGVlIn0.t_v73kaAMUtoGBPESpw3uA';

    const map = new mapboxgl.Map({
        container: 'mapCanvas',
        style: 'mapbox://styles/mapbox/light-v11',
        center: [-74.006, 40.7128],
        zoom: 10
    });

    // Mapbox Geocoder 
    const geocoder = new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        mapboxgl: mapboxgl,
        marker: true,
        placeholder: "Search for your location...",
        zoom: 14
    });

    document.getElementById('geocoder-container').appendChild(geocoder.onAdd(map));

    let jsonData = null;
    let selectMode = false;
    let marker = null;

    map.on("click", (e) => {
        if (!selectMode) return;

        const { lng, lat } = e.lngLat;

        if (marker) {
            marker.setLngLat([lng, lat]);
        } else {
            marker = new mapboxgl.Marker()
                .setLngLat([lng, lat])
                .addTo(map);
        }

        map.flyTo({ center: [lng, lat], zoom: 15 });

        document.getElementById("location-info").innerText = `Selected Location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;

        selectMode = false;
    });

    // Load the CSV and GeoJSON files
    Promise.all([
        d3.csv("zip_df.csv"),
        d3.json("nyc_zip_codes_with_centroids.geojson"),
        d3.json("nyc_open_space.geojson")
    ]).then(([zipData, zipGeoJSON, parkGeoJSON]) => {

        const biteByZip = {};
        const dogsByZip = {};

        zipData.forEach(d => {
            biteByZip[d.zip_code] = +d.number_of_bites;
            dogsByZip[d.zip_code] = +d.number_of_dogs;
        });

        // ------ Build centroid point features for ZIP codes ------
        const zipCentroidFeatures = [];

        zipGeoJSON.features.forEach(f => {
            const zip = f.properties.postcode || f.properties.ZIPCODE || f.properties.zip || f.properties.postalCode;
            const numBites = biteByZip[zip] || 0;
            const numDogs = dogsByZip[zip] || 0;
            f.properties.number_of_bites = numBites;
            f.properties.number_of_dogs = numDogs;

            // Add point for centroid layer if centroid coords exist
            if (f.properties.centroid_lon && f.properties.centroid_lat) {
                zipCentroidFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [f.properties.centroid_lon, f.properties.centroid_lat]
                    },
                    properties: {
                        zip: zip,
                        number_of_bites: numBites
                    }
                });
            }
        });

        const zipCentroidGeoJSON = {
            type: 'FeatureCollection',
            features: zipCentroidFeatures
        };

        console.log("Number of ZIP dots created:", zipCentroidFeatures.length);

        map.on("load", () => {

            // ---- ZIP shape layer colored by number_of_dogs ----
            map.addSource('zipcodes', {
                type: 'geojson',
                data: zipGeoJSON
            });

            map.addLayer({
    'id': 'zip-dog-fills',
    'type': 'fill',
    'source': 'zipcodes',
    'paint': {
        'fill-color': [
            'interpolate',
            ['linear'],
            ['get', 'number_of_dogs'],
            0, '#e0f3f8',
            500, '#abd9e9',
            2000, '#74add1',
            5000, '#4575b4'
        ],
        'fill-opacity': 0.3
    }
});


//
            // map.addLayer({
            //     'id': 'zip-dog-borders',
            //     'type': 'line',
            //     'source': 'zipcodes',
                
            //     'paint': {
            //         'line-color': '#555',
            //         'line-width': 1
            //     }
                
            // });

            // ---- ZIP dog hover popup ----
            const dogPopup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'zip-dog-fills', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const props = e.features[0].properties;
                const coordinates = e.lngLat;

                dogPopup
                    .setLngLat(coordinates)
                    .setHTML(`<strong>ZIP: ${props.postcode}</strong><br>Dogs: ${props.number_of_dogs}`)
                    .addTo(map);
            });

            map.on('mouseleave', 'zip-dog-fills', () => {
                map.getCanvas().style.cursor = '';
                dogPopup.remove();
            });

            // ---- ZIP centroid dots ----
            map.addSource('zip-centroids', {
                type: 'geojson',
                data: zipCentroidGeoJSON
            });

            map.addLayer({
                'id': 'zip-centroid-dots',
                'type': 'circle',
                'source': 'zip-centroids',
                'paint': {
                    'circle-radius': [
                        'interpolate',
                        ['linear'],
                        ['get', 'number_of_bites'],
                        0, 4,
                        500, 12
                    ],
                   'circle-color': [
    'interpolate',
    ['linear'],
    ['get', 'number_of_bites'],
    0, '#ffffcc',    // pale yellow
    50, '#ffeda0',   // soft orange-yellow
    200, '#feb24c',  // bright orange
    500, '#f03b20'   // deep orange-red (still orange-toned)
],
'circle-opacity': 0.7


                }
            });

            // ---- ZIP dot hover popup ----
            const zipPopup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'zip-centroid-dots', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const props = e.features[0].properties;
                const coordinates = e.lngLat;

                zipPopup
                    .setLngLat(coordinates)
                    .setHTML(`<strong>ZIP: ${props.zip}</strong><br>Bites: ${props.number_of_bites}`)
                    .addTo(map);
            });

            map.on('mouseleave', 'zip-centroid-dots', () => {
                map.getCanvas().style.cursor = '';
                zipPopup.remove();
            });

            // ---- Parks ----
            map.addSource('parks', {
                type: 'geojson',
                data: parkGeoJSON
            });

            map.addLayer({
                'id': 'park-fills',
                'type': 'fill',
                'source': 'parks',
                'paint': {
                    'fill-color': '#72c27e',
                    'fill-opacity': 0.4
                }
            });

            // map.addLayer({
            //     'id': 'park-borders',
            //     'type': 'line',
            //     'source': 'parks',
            //     'paint': {
            //         'line-color': '#2e8b57',
            //         'line-width': 1
            //     }
            // });

            // ---- Park hover popup ----
            const parkPopup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'park-fills', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const parkName = e.features[0].properties.PARK_NAME || "Unnamed Park";
                const coordinates = e.lngLat;

                parkPopup
                    .setLngLat(coordinates)
                    .setHTML(`<strong>${parkName}</strong>`)
                    .addTo(map);
            });

            map.on('mouseleave', 'park-fills', () => {
                map.getCanvas().style.cursor = '';
                parkPopup.remove();
            });

        });

    });

    // Layer toggle function
    function toggleLayer(layerBaseId) {
    const layerIds = [layerBaseId];

    // If the layer is a 'fills' layer, add the corresponding 'borders' layer
    if (layerBaseId.includes('fills')) {
        layerIds.push(layerBaseId.replace('fills', 'borders'));
    }

    layerIds.forEach(layer => {
        if (!map.getLayer(layer)) return;
        const visibility = map.getLayoutProperty(layer, 'visibility');
        map.setLayoutProperty(layer, 'visibility',
            (visibility === 'visible' || visibility === undefined) ? 'none' : 'visible'
        );
    });
}


</script>



</body>