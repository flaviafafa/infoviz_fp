<html>

<head>
    <meta charset="UTF-8">

    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script
        src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.min.js"></script>
    <link rel="stylesheet"
        href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.1.0/mapbox-gl-geocoder.css">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        body {
            margin: 0px;
            font-family: 'Baloo 2', cursive;
            color: #041F3D;
            display: flex;
            flex-direction: column;
        }

        .container-centered {
            width: 96%;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
        }

        h2 {
            font-size: 28px;
            font-weight: 700;
        }

        .colored-bg {
            background-color: #ffefda
        }

        .session {
            padding-top: 40px;
            padding-bottom: 40px;
        }

    .map-container {
        position: relative;
        width: 100%;
        height: 100vh;
    }

    #mapCanvas {
        width: 80%;
        height: 80%;
    }

    #geocoder-container {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 300px;
        z-index: 2;
    }

    .sidebar {
        position: absolute;
        top: 80px;
        right: 20px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        padding: 12px 16px;
        z-index: 2;
    }

    .sidebar button {
        display: block;
        width: 180px;
        margin: 8px 0;
        padding: 10px 14px;
        background-color: #4285f4;
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 15px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    .sidebar button:hover {
        background-color: #3367d6;
    }

    .sidebar button:active {
        background-color: #254ba0;
    }


        #geocoder-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 50%;
            z-index: 1;
        }
    </style>


</head>

<body>

    <!--Introduction-->
    <div class="session container-centered">
        <div>
            <h1 style="font-weight:800; font-size: 32px;">
                TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE TITLE
            </h1>
            <h3>Flavia Jiang, Curtis Xu, Xinyi Zhou</h3>

            <div>Intro paragraph</div>
        </div>
    </div>

    <!--Bite incidents by breed-->
    <div class="session colored-bg">
        <div id="container-breed" class="container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>
            <svg id="svg-breed" height="540" width="1200"></svg>
        </div>
    </div>

    <!--Bite incidents by gender x spay & neuter-->
    <div class="session">
        <div id="container-gender" class="container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>

        </div>
    </div>

    <!--Bite incidents by age-->
    <div class="session colored-bg">
        <div id="container-age" class="colored-bg container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>
            <svg id="svg-age" height="600" width="720"></svg>
        </div>
    </div>

    <!--Bite incidents by time-->
    <div class="session">
        <div id="container-time" class="container-centered">
            <h2>TITLE TITLE TITLE TITLE TITLE TITLE </h2>
            <div style="display: flex; flex-direction: row; justify-content: center; align-items: center; gap: 50px">
                <svg id="svg-time" height="450" width="650"></svg>
                <div style="display:flex; flex-direction:column">
                    <svg id="svg-temp" height="300" width="450"></svg>
                    <svg id="svg-precip" height="300" width="450"></svg>
                </div>

            </div>

        </div>
    </div>

    <!--Bite incidents by neighborhood-->
    <div class="session colored-bg">
        <div id="container-zip" class="colored-bg container-centered">
            <h2>Interactive Map </h2>

        </div>

        <div class="map-container">
            <div id="mapCanvas"></div>
            <div id="geocoder-container"></div>
            <div id="layer-control" class="sidebar">
                <button onclick="toggleLayer('zip-centroid-dots')">Dog Bites</button><br>
                <button onclick="toggleLayer('zip-dog-fills')">Dog Distribution</button><br>
                <button onclick="toggleLayer('park-fills')">Open Spaces / Parks</button>
                
            </div>
       
        </div>


    </div>



    <script>
        const requestData = async () => {

            // Bite incidents by breed
            const breedData = await d3.csv("breed_df.csv");

            breedData.forEach(d => {
                d.bite_score = 16 - +d.bite_score_ranking;
                d.aggresiveness_score = 16 - +d.aggresiveness_score_ranking;
            });

            const svg_breed = d3.select("#svg-breed");
            const width_breed = +svg_breed.attr("width");
            const height_breed = +svg_breed.attr("height");
            const margin_breed = { top: 50, right: 20, bottom: 60, left: 40 };
            const chartWidth_breed = width_breed - margin_breed.left - margin_breed.right;
            const chartHeight_breed = height_breed - margin_breed.top - margin_breed.bottom;

            const g_breed = svg_breed.append("g")
                .attr("transform", `translate(${margin_breed.left},${margin_breed.top})`);

            g_breed.append("line")
                .attr("x1", 0)
                .attr("y1", chartHeight_breed / 2)
                .attr("x2", chartWidth_breed)
                .attr("y2", chartHeight_breed / 2)
                .attr("stroke", "#041F3D") 
                .attr("stroke-width", 2)
                .lower(); 

            const xScale_breed = d3.scaleBand()
                .domain(breedData.map(d => d.breed))
                .range([0, chartWidth_breed])
                .padding(0.4);

            const yScale_breed = d3.scaleLinear()
                .domain([0, 15])
                .range([chartHeight_breed / 2, 0]);

            const yScale_breed_neg = d3.scaleLinear()
                .domain([0, 15])
                .range([0, chartHeight_breed / 2]);

            // Add y-axis titles
            g_breed.append("text")
                .attr("y", 0)
                .attr("x", chartWidth_breed/2)
                .attr("text-anchor", "middle")
                .text("Bite Frequency Score")
                .style("font-size", "28px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            g_breed.append("text")
                .attr("y", 450)
                .attr("x", chartWidth_breed/2)
                .attr("text-anchor", "middle")
                .text("Owner-Rated Aggressiveness Score")
                .style("font-size", "28px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");

            // Create a group for each breed 
            const breedGroups = g_breed.selectAll(".breed-group")
                .data(breedData)
                .join("g")
                .attr("class", "breed-group")
                .attr("transform", d => `translate(${xScale_breed(d.breed)},0)`);

            // Add bars
            breedGroups.append("rect")
                .attr("class", "bar-bite")
                .attr("width", xScale_breed.bandwidth())
                .attr("y", d => yScale_breed(d.bite_score))
                .attr("height", d => chartHeight_breed / 2 - yScale_breed(d.bite_score))
                .attr("fill", "#ff8c42")
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("opacity", 0.8);

            breedGroups.append("rect")
                .attr("class", "bar-agg")
                .attr("width", xScale_breed.bandwidth())
                .attr("y", chartHeight_breed / 2)
                .attr("height", d => yScale_breed_neg(d.aggresiveness_score))
                .attr("fill", "#3ec9c1")
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("opacity", 0.8);

            // Add image circles
            breedGroups.append("circle")
                .attr("class", "breed-image")
                .attr("cx", xScale_breed.bandwidth() / 2)
                .attr("cy", chartHeight_breed / 2)
                .attr("r", xScale_breed.bandwidth() * 0.75)
                .attr("fill", "white")
                .attr("stroke", "#041f3d")
                .attr("stroke-width", 2);

            // Add images
            breedGroups.append("image")
                .attr("class", "breed-img")
                .attr("xlink:href", d => `dog_cartoons/${d.breed.replaceAll(' ', '_')}.png`)
                .attr("x", -xScale_breed.bandwidth() * 0.2)
                .attr("y", chartHeight_breed/2 - xScale_breed.bandwidth() * 0.65)
                .attr("width", xScale_breed.bandwidth() * 1.4)
                .attr("height", xScale_breed.bandwidth() * 1.4);

            // Style tooltip
            const tooltip = g_breed.append("g")
                .attr("class", "tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            tooltip.append("rect")
                .attr("width", 480)
                .attr("height", 150)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            tooltip.append("image")
                .attr("class", "tooltip-img")
                .attr("x", 10)
                .attr("y", 20)
                .attr("width", 110)
                .attr("height", 110);

            tooltip.append("text")
                .attr("class", "tooltip-title")
                .attr("x", 130)
                .attr("y", 50)
                .style("font-size", "20px")
                .style("font-weight", "bold");

            tooltip.append("text")
                .attr("class", "tooltip-bite")
                .attr("x", 130)
                .attr("y", 80)
                .style("font-size", "18px");

            tooltip.append("text")
                .attr("class", "tooltip-agg")
                .attr("x", 130)
                .attr("y", 110)
                .style("font-size", "18px");

            // Hover-over functions
            breedGroups.on("mouseover", function(event, d) {

                d3.select(this).selectAll("rect")
                    .attr("opacity", 1)
                    .attr("stroke", "#041F3D")
                    .attr("stroke-width", 2);

                // Dim other breeds
                breedGroups.filter(dd => dd !== d).selectAll("rect")
                    .attr("opacity", 0.3);

                const [mouseX, mouseY] = d3.pointer(event, svg_breed.node());
    
                const tooltipWidth = 480;
                const tooltipHeight = 150;
                const padding = 10;
    
                let x;
                if (mouseX > width_breed - tooltipWidth - padding) {
                    x = mouseX - tooltipWidth - padding;
                } else {
                    x = mouseX + padding;
                }
    
                let y;
                if (mouseY < chartHeight_breed / 2) { 
                    y = mouseY + padding;
                } else {
                    y = mouseY - tooltipHeight - padding;
                }
    
                // Do boundary checks
                y = Math.max(padding, Math.min(y, height_breed - tooltipHeight - padding));

                tooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);

                tooltip.select(".tooltip-img")
                    .attr("xlink:href", `dog_cartoons/${d.breed.replaceAll(' ', '_')}.png`);

                tooltip.select(".tooltip-title")
                    .text(d.breed);

                tooltip.select(".tooltip-bite")
                    .html(`Bite Frequency: <tspan style="font-weight:bold">${d.bite_score} out of 15</tspan>`);

                tooltip.select(".tooltip-agg")
                    .html(`Owner-Rated Aggressiveness: <tspan style="font-weight:bold">${d.aggresiveness_score} out of 15</tspan>`);
            })
            .on("mousemove", function(event) {
                const [mouseX, mouseY] = d3.pointer(event, svg_breed.node());
    
                const tooltipWidth = 480;
                const tooltipHeight = 150;
                const padding = 10;
    
                let x;
                if (mouseX > width_breed - tooltipWidth - padding) {
                    x = mouseX - tooltipWidth - padding;
                } else {
                    x = mouseX + padding;
                }
    
                let y;
                if (mouseY < chartHeight_breed / 2) {
                    y = mouseY + padding;
                } else {
                    y = mouseY - tooltipHeight - padding;
                }
    
                // Move tooltip
                y = Math.max(padding, Math.min(y, height_breed - tooltipHeight - padding));

                tooltip.attr("transform", `translate(${x},${y})`);
            })
            .on("mouseout", function() {
                breedGroups.selectAll("rect")
                    .attr("opacity", 0.8)
                    .attr("stroke", "none");

                tooltip.style("opacity", 0);
            });

            // Create axes
            const yAxis_breed = d3.axisLeft(yScale_breed)
                .tickValues([0, 3, 6, 9, 12, 15])
                .tickSizeOuter(0);

            g_breed.append("g")
                .attr("class", "y-axis")
                .call(yAxis_breed)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text").style("font-size", "18px").style("fill", "#041F3D").attr("dx", "-0.2em"));

            const yAxis_breed_neg = d3.axisLeft(yScale_breed_neg)
                .tickValues([0, 3, 6, 9, 12, 15])
                .tickSizeOuter(0);

            g_breed.append("g")
                .attr("transform", `translate(0,${chartHeight_breed / 2})`)
                .attr("class", "y-axis")
                .call(yAxis_breed_neg)
                .call(g => g.select(".domain").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick line").attr("stroke", "#041F3D").attr("stroke-width", 2))
                .call(g => g.selectAll(".tick text").style("font-size", "18px").style("fill", "#041F3D").attr("dx", "-0.2em"));


            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------

            // Bite incidents by age
            const ageData = await d3.csv("age_df.csv");

            const svg_age = d3.select("#svg-age");

            const width_age = +svg_age.attr("width");
            const height_age = +svg_age.attr("height");
            const margin_age = { top: 50, right: 90, bottom: 80, left: 10 };
            const chartWidth_age = width_age - margin_age.left - margin_age.right;
            const chartHeight_age = height_age - margin_age.top - margin_age.bottom;

            const g_age = svg_age.append("g")
                .attr("transform", `translate(${margin_age.left},${margin_age.top})`);

            ageData.forEach(d => {
                d.age = +d.age;
                d.bite_versus_population_ratio = +d.bite_versus_population_ratio;
                d.ageLabel = d.age === 1 ? "≤1" : d.age.toString();
            });

            // Set up scales
            const xScale_age = d3.scaleBand()
                .domain(ageData.map(d => d.ageLabel))
                .range([0, chartWidth_age])
                .padding(0.3);

            const maxRatio = d3.max(ageData, d => d.bite_versus_population_ratio);
            const yScale_age = d3.scaleLinear()
                .domain([0, maxRatio * 1.1])
                .range([chartHeight_age, 0]);

            // Add horizontal line at y=1
            g_age.append("line")
                .attr("x1", 0)
                .attr("y1", yScale_age(1))
                .attr("x2", chartWidth_age)
                .attr("y2", yScale_age(1))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");

            g_age.append("text")
                .attr("x", chartWidth_age - 10)
                .attr("y", yScale_age(1) - 12)
                .attr("text-anchor", "end")
                .text("1 (average)")
                .style("font-size", "22px")
                .style("fill", "#041F3D");

            // Add lollipops
            const colorScale = d3.scaleThreshold()
                .domain([0.8, 1.6])
                .range(["#ffd1a8", "#ff8c42", "#e65c00"]);

            const lollipopGroups = g_age.selectAll(".lollipop-group")
                .data(ageData)
                .join("g")
                .attr("class", "lollipop-group")
                .attr("transform", d => `translate(${xScale_age(d.ageLabel) + xScale_age.bandwidth()/2},0)`);

            lollipopGroups.append("line")
                .attr("class", "lollipop-line")
                .attr("y1", yScale_age(0))
                .attr("y2", d => yScale_age(d.bite_versus_population_ratio))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            lollipopGroups.append("circle")
                .attr("class", "lollipop-circle")
                .attr("cy", d => yScale_age(d.bite_versus_population_ratio))
                .attr("r", 13)
                .attr("fill", d => colorScale(d.bite_versus_population_ratio))
                .attr("stroke", "#041F3D")
                .attr("stroke-width", 2);

            // x axis
            const xAxis = g_age.append("g")
                .attr("transform", `translate(0,${chartHeight_age})`)
                .call(d3.axisBottom(xScale_age));

            xAxis.selectAll("text")
                .style("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "#041F3D")
                .attr("dy", "1em");

            xAxis.append("text")
                .attr("x", chartWidth_age / 2)
                .attr("y", 60)
                .attr("text-anchor", "middle")
                .text("Age")
                .style("font-size", "28px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D")
                .style("font-family", "'Baloo 2', cursive");
            
            xAxis.select(".domain")
                .attr("stroke-width", 2);

            xAxis.selectAll(".tick line")
                .attr("stroke-width", 2); 

            // y axis
            const yAxis = g_age.append("g")
                .attr("transform", `translate(${chartWidth_age},0)`)
                .call(d3.axisRight(yScale_age).ticks(5));

            yAxis.select(".domain")
                .attr("stroke-width", 2);

            yAxis.selectAll(".tick line")
                .attr("stroke-width", 2); 

            yAxis.selectAll("text")
                .style("font-size", "18px")
                .style("fill", "#041F3D")
                .attr("dx", "0.3em");

            g_age.append("text")
                .attr("y", -20)
                .attr("x", chartWidth_age-90)
                .attr("text-anchor", "middle")
                .text("Bite Frequency Score")
                .style("font-size", "28px")
                .style("font-weight", "bold")
                .style("fill", "#041F3D");
            
            // Tooltip
            const ageTooltip = g_age.append("g")
                .attr("class", "age-tooltip")
                .style("opacity", 0)
                .style("pointer-events", "none");

            ageTooltip.append("rect")
                .attr("width", 400)
                .attr("height", 100)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("fill", "white")
                .attr("stroke-width", 4);

            ageTooltip.append("text")
                .attr("class", "tooltip-interpretation")
                .attr("x", 20)
                .attr("y", 40)
                .attr("fill", "#041F3D")
                .style("font-size", "20px")
                .style("font-family", "'Baloo 2', cursive");

            // Hover-over events
            lollipopGroups.on("mouseover", function(event, d) {
                const borderColor = colorScale(d.bite_versus_population_ratio);
                d3.select(this).select(".lollipop-circle")
                    .attr("r", 17)
                    .attr("stroke-width", 4);
    
                d3.select(this).select(".lollipop-line")
                    .attr("stroke-width", 4);

                ageTooltip.select("rect")
                    .attr("stroke", borderColor);

                const ratio = d.bite_versus_population_ratio.toFixed(2);
                const comparison = d.bite_versus_population_ratio > 1 ? "higher" : "lower";

                const htmlContent = `At the age of <tspan style="font-weight:bold">${d.age === 1 ? "1 year or younger" : `${d.age} years`}</tspan>, the bite rate is <tspan style="font-weight:bold">${ratio}</tspan> times <tspan style="font-weight:bold">${comparison}</tspan> than expected based on population share.`;

                // text wrapping
                const tooltipText = ageTooltip.select(".tooltip-interpretation");
                tooltipText.selectAll("*").remove();

                const maxCharsPerLine = 40;
                const words = htmlContent.split(' ');
                let line = [];
                let lineNumber = 0;
                const xPos = 20;
                const initialYPos = 40;
                const lineHeight = 30;

                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontFamily = "'Baloo 2', cursive";
                tempDiv.style.fontSize = '20px';
                document.body.appendChild(tempDiv);

                words.forEach((word, i) => {
                    line.push(word);
                    tempDiv.innerHTML = line.join(' ');
                    const testWidth = tempDiv.offsetWidth;
    
                    if (testWidth > 360 && line.length > 1) { 
                        line.pop();
                        tooltipText.append("tspan")
                            .attr("x", xPos)
                            .attr("y", initialYPos + (lineNumber * lineHeight))
                            .html(line.join(' '));
        
                        line = [word];
                        lineNumber++;
                    }
                });

                // Add the last line
                if (line.length > 0) {
                    tooltipText.append("tspan")
                        .attr("x", xPos)
                        .attr("y", initialYPos + (lineNumber * lineHeight))
                        .html(line.join(' '));
                }

                document.body.removeChild(tempDiv);

                const tooltipHeight = 70 + (lineNumber * lineHeight);
                ageTooltip.select("rect")
                    .attr("height", tooltipHeight);
                
                const [mouseX, mouseY] = d3.pointer(event, svg_age.node());
                const tooltipWidth = 400;
                const tooltipHeightValue = tooltipHeight;

                let x = mouseX + 10;
                if (x + tooltipWidth > width_age) {
                    x = width_age - tooltipWidth - 10;
                }

                let y = mouseY + 10;
                if (y + tooltipHeightValue > height_age) {
                    y = height_age - tooltipHeightValue - 10;
                }

                y = Math.max(10, y);

                ageTooltip.style("opacity", 1)
                    .attr("transform", `translate(${x},${y})`);
            })
            .on("mouseout", function() {
                d3.select(this).select(".lollipop-circle")
                    .attr("r", 13)
                    .attr("stroke-width", 2);
    
                d3.select(this).select(".lollipop-line")
                    .attr("stroke-width", 2);

                ageTooltip.style("opacity", 0);
            })
            .on("mousemove", function(event) {
                const [mouseX, mouseY] = d3.pointer(event, svg_age.node());
                const tooltipWidth = 400;
                const tooltipHeight = +ageTooltip.select("rect").attr("height");
    
                let x = mouseX + 10;
                if (x + tooltipWidth > width_age) {
                    x = width_age - tooltipWidth - 10;
                }
    
                let y = mouseY + 10;
                if (y + tooltipHeight > height_age) {
                    y = height_age - tooltipHeight - 10;
                }
                y = Math.max(10, y);
    
                ageTooltip.attr("transform", `translate(${x},${y})`);
            })

            // --------------------------------------------------
            // --------------------------------------------------
            // --------------------------------------------------


            // Bite incidents by time
            const timeData = await d3.csv("time_df.csv");
            console.log(timeData);

            const monthlyTotals = {};

            timeData.forEach(d => {
                const key = `${String(d.month).padStart(2, '0')}-${d.year}`;
                const bites = +d.number_of_bites;
                const temp = +d.temperature_avg;
                const precip = +d.precipitation;

                if (!monthlyTotals[key]) {
                    monthlyTotals[key] = {
                        monthYear: key,
                        year: +d.year,
                        month: +d.month,
                        totalBites: 0,
                        tempSum: 0,
                        precipitation: 0,
                        dayCount: 0
                    };
                }
                monthlyTotals[key].totalBites += bites;
                monthlyTotals[key].tempSum += temp;
                monthlyTotals[key].dayCount += 1;
                monthlyTotals[key].precipitation += precip;
            });

            const monthlyData = Object.values(monthlyTotals).map(d => {
                return {
                    monthYear: d.monthYear,
                    year: d.year,
                    month: d.month,
                    totalBites: d.totalBites,
                    avgTemp: d.tempSum / d.dayCount,
                    avgPrecip: d.precipitation / d.dayCount,
                };
            }).sort((a, b) => a.year - b.year || a.month - b.month);

            console.log(monthlyData);

            const svg_time = d3.select("#svg-time");
            const width_time = +svg_time.attr("width");
            const height_time = +svg_time.attr("height");
            const margin_time = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_time = width_time - margin_time.left - margin_time.right;
            const chartHeight_time = height_time - margin_time.top - margin_time.bottom;

            const g_time = svg_time.append("g")
                .attr("transform", `translate(${margin_time.left},${margin_time.top})`);

            const xScale_time = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_time]);

            const yScale_time = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.totalBites))
                .range([chartHeight_time, 0]);

            const time_bite_line = d3.line()
                .x((d, i) => xScale_time(i))
                .y(d => yScale_time(d.totalBites));

            g_time.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "#FD8C40")
                .attr("stroke-width", 2)
                .attr("d", time_bite_line);



            //x-Axis-time
            const xAxis_time = d3.axisBottom(xScale_time)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => {
                    if (i % 12 === 0) {
                        return monthlyData[i].monthYear;
                    }
                    return '';
                });

            g_time.append("g")
                .attr("transform", `translate(0,${chartHeight_time})`)
                .call(xAxis_time)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            // Y-axis-time
            const yAxis_time = d3.axisLeft(yScale_time);
            g_time.append("g").call(yAxis_time);

            // Y-axis-time label
            svg_time.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_time / 2 + 30)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Number of Bites");

            // X-axis-time label
            svg_time.append("text")
                .attr("x", margin_time.left + chartWidth_time / 2)
                .attr("y", height_time - 5)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Time (Month-Year)");


            const svg_temp = d3.select("#svg-temp");
            const width_temp = +svg_temp.attr("width");
            const height_temp = +svg_temp.attr("height");
            const margin_temp = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_temp = width_temp - margin_temp.left - margin_temp.right;
            const chartHeight_temp = height_temp - margin_temp.top - margin_temp.bottom;

            const g_temp = svg_temp.append("g")
                .attr("transform", `translate(${margin_temp.left},${margin_temp.top})`);

            const xScale_temp = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_temp]);

            const yScale_temp = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.avgTemp))
                .range([chartHeight_temp, 0]);

            const time_temp_line = d3.line()
                .x((d, i) => xScale_temp(i))
                .y(d => yScale_temp(d.avgTemp));

            g_temp.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "#F4D35E")
                .attr("stroke-width", 2)
                .attr("d", time_temp_line);


            g_temp.append("g")
                .attr("transform", `translate(0,${chartHeight_time})`)
                .call(xAxis_time)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            //x-Axis-temp
            const xAxis_temp = d3.axisBottom(xScale_temp)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => {
                    if (i % 12 === 0) {
                        return monthlyData[i].monthYear;
                    }
                    return '';
                });

            g_temp.append("g")
                .attr("transform", `translate(0,${chartHeight_temp})`)
                .call(xAxis_temp)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            // Y-axis
            const yAxis_temp = d3.axisLeft(yScale_temp);
            g_temp.append("g").call(yAxis_temp);

            // Y-axis label
            svg_temp.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_temp / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Average Temperature(F)");

            // X-axis label
            svg_temp.append("text")
                .attr("x", margin_temp.left + chartWidth_temp / 2)
                .attr("y", height_temp - 5)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Time (Month-Year)");


            const svg_precip = d3.select("#svg-precip");
            const width_precip = +svg_precip.attr("width");
            const height_precip = +svg_precip.attr("height");
            const margin_precip = { top: 10, right: 10, bottom: 70, left: 70 };
            const chartWidth_precip = width_precip - margin_precip.left - margin_precip.right;
            const chartHeight_precip = height_precip - margin_precip.top - margin_precip.bottom;

            const g_precip = svg_precip.append("g")
                .attr("transform", `translate(${margin_precip.left},${margin_precip.top})`);

            const xScale_precip = d3.scaleLinear()
                .domain([0, monthlyData.length - 1])
                .range([0, chartWidth_precip]);

            const yScale_precip = d3.scaleLinear()
                .domain(d3.extent(monthlyData, d => d.avgPrecip))
                .range([chartHeight_precip, 0]);

            const time_precip_line = d3.line()
                .x((d, i) => xScale_precip(i))
                .y(d => yScale_precip(d.avgPrecip));

            g_precip.append("path")
                .datum(monthlyData)
                .attr("fill", "none")
                .attr("stroke", "#3ec9c1")
                .attr("stroke-width", 2)
                .attr("d", time_precip_line);


            //x-Axis-temp
            const xAxis_precip = d3.axisBottom(xScale_precip)
                .ticks(monthlyData.length)
                .tickFormat((d, i) => {
                    if (i % 12 === 0) {
                        return monthlyData[i].monthYear;
                    }
                    return '';
                });

            g_precip.append("g")
                .attr("transform", `translate(0,${chartHeight_precip})`)
                .call(xAxis_precip)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            g_precip.append("g")
                .attr("transform", `translate(0,${chartHeight_precip})`)
                .call(xAxis_precip)
                .selectAll("text")
                .attr("transform", "rotate(45)")
                .style("text-anchor", "start");

            // Y-axis
            const yAxis_precip = d3.axisLeft(yScale_precip);
            g_precip.append("g").call(yAxis_precip);
            d => d.avgprecip
            // Y-axis label
            svg_precip.append("text")
                .attr("transform", `rotate(-90)`)
                .attr("y", 10)
                .attr("x", -height_precip / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Average Precipitation");

            // X-axis label
            svg_precip.append("text")
                .attr("x", margin_precip.left + chartWidth_precip / 2)
                .attr("y", height_precip - 5)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Time (Month-Year)");
        }

        requestData();
    </script>

<script>
    // Map framework
    mapboxgl.accessToken = 'pk.eyJ1Ijoia3g2NCIsImEiOiJjbGkzd2E1dmsxMzNoM2twY2p2azF0bGVlIn0.t_v73kaAMUtoGBPESpw3uA';

    const map = new mapboxgl.Map({
        container: 'mapCanvas',
        style: 'mapbox://styles/mapbox/light-v11',
        center: [-74.006, 40.7128],
        zoom: 10
    });

    // Mapbox Geocoder 
    const geocoder = new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        mapboxgl: mapboxgl,
        marker: true,
        placeholder: "Search for your location...",
        zoom: 14
    });

    document.getElementById('geocoder-container').appendChild(geocoder.onAdd(map));

    let jsonData = null;
    let selectMode = false;
    let marker = null;

    map.on("click", (e) => {
        if (!selectMode) return;

        const { lng, lat } = e.lngLat;

        if (marker) {
            marker.setLngLat([lng, lat]);
        } else {
            marker = new mapboxgl.Marker()
                .setLngLat([lng, lat])
                .addTo(map);
        }

        map.flyTo({ center: [lng, lat], zoom: 15 });

        document.getElementById("location-info").innerText = `Selected Location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;

        selectMode = false;
    });

    // Load the CSV and GeoJSON files
    Promise.all([
        d3.csv("zip_df.csv"),
        d3.json("nyc_zip_codes_with_centroids.geojson"),
        d3.json("nyc_open_space.geojson")
    ]).then(([zipData, zipGeoJSON, parkGeoJSON]) => {

        const biteByZip = {};
        const dogsByZip = {};

        zipData.forEach(d => {
            biteByZip[d.zip_code] = +d.number_of_bites;
            dogsByZip[d.zip_code] = +d.number_of_dogs;
        });

        // ------ Build centroid point features for ZIP codes ------
        const zipCentroidFeatures = [];

        zipGeoJSON.features.forEach(f => {
            const zip = f.properties.postcode || f.properties.ZIPCODE || f.properties.zip || f.properties.postalCode;
            const numBites = biteByZip[zip] || 0;
            const numDogs = dogsByZip[zip] || 0;
            f.properties.number_of_bites = numBites;
            f.properties.number_of_dogs = numDogs;

            // Add point for centroid layer if centroid coords exist
            if (f.properties.centroid_lon && f.properties.centroid_lat) {
                zipCentroidFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [f.properties.centroid_lon, f.properties.centroid_lat]
                    },
                    properties: {
                        zip: zip,
                        number_of_bites: numBites
                    }
                });
            }
        });

        const zipCentroidGeoJSON = {
            type: 'FeatureCollection',
            features: zipCentroidFeatures
        };

        console.log("Number of ZIP dots created:", zipCentroidFeatures.length);

        map.on("load", () => {

            // ---- ZIP shape layer colored by number_of_dogs ----
            map.addSource('zipcodes', {
                type: 'geojson',
                data: zipGeoJSON
            });

            map.addLayer({
    'id': 'zip-dog-fills',
    'type': 'fill',
    'source': 'zipcodes',
    'paint': {
        'fill-color': [
            'interpolate',
            ['linear'],
            ['get', 'number_of_dogs'],
            0, '#e0f3f8',
            500, '#abd9e9',
            2000, '#74add1',
            5000, '#4575b4'
        ],
        'fill-opacity': 0.3
    }
});


//
            // map.addLayer({
            //     'id': 'zip-dog-borders',
            //     'type': 'line',
            //     'source': 'zipcodes',
                
            //     'paint': {
            //         'line-color': '#555',
            //         'line-width': 1
            //     }
                
            // });

            // ---- ZIP dog hover popup ----
            const dogPopup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'zip-dog-fills', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const props = e.features[0].properties;
                const coordinates = e.lngLat;

                dogPopup
                    .setLngLat(coordinates)
                    .setHTML(`<strong>ZIP: ${props.postcode}</strong><br>Dogs: ${props.number_of_dogs}`)
                    .addTo(map);
            });

            map.on('mouseleave', 'zip-dog-fills', () => {
                map.getCanvas().style.cursor = '';
                dogPopup.remove();
            });

            // ---- ZIP centroid dots ----
            map.addSource('zip-centroids', {
                type: 'geojson',
                data: zipCentroidGeoJSON
            });

            map.addLayer({
                'id': 'zip-centroid-dots',
                'type': 'circle',
                'source': 'zip-centroids',
                'paint': {
                    'circle-radius': [
                        'interpolate',
                        ['linear'],
                        ['get', 'number_of_bites'],
                        0, 4,
                        500, 12
                    ],
                   'circle-color': [
    'interpolate',
    ['linear'],
    ['get', 'number_of_bites'],
    0, '#ffffcc',    // pale yellow
    50, '#ffeda0',   // soft orange-yellow
    200, '#feb24c',  // bright orange
    500, '#f03b20'   // deep orange-red (still orange-toned)
],
'circle-opacity': 0.7


                }
            });

            // ---- ZIP dot hover popup ----
            const zipPopup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'zip-centroid-dots', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const props = e.features[0].properties;
                const coordinates = e.lngLat;

                zipPopup
                    .setLngLat(coordinates)
                    .setHTML(`<strong>ZIP: ${props.zip}</strong><br>Bites: ${props.number_of_bites}`)
                    .addTo(map);
            });

            map.on('mouseleave', 'zip-centroid-dots', () => {
                map.getCanvas().style.cursor = '';
                zipPopup.remove();
            });

            // ---- Parks ----
            map.addSource('parks', {
                type: 'geojson',
                data: parkGeoJSON
            });

            map.addLayer({
                'id': 'park-fills',
                'type': 'fill',
                'source': 'parks',
                'paint': {
                    'fill-color': '#72c27e',
                    'fill-opacity': 0.4
                }
            });

            // map.addLayer({
            //     'id': 'park-borders',
            //     'type': 'line',
            //     'source': 'parks',
            //     'paint': {
            //         'line-color': '#2e8b57',
            //         'line-width': 1
            //     }
            // });

            // ---- Park hover popup ----
            const parkPopup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mouseenter', 'park-fills', (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const parkName = e.features[0].properties.PARK_NAME || "Unnamed Park";
                const coordinates = e.lngLat;

                parkPopup
                    .setLngLat(coordinates)
                    .setHTML(`<strong>${parkName}</strong>`)
                    .addTo(map);
            });

            map.on('mouseleave', 'park-fills', () => {
                map.getCanvas().style.cursor = '';
                parkPopup.remove();
            });

        });

    });

    // Layer toggle function
    function toggleLayer(layerBaseId) {
    const layerIds = [layerBaseId];

    // If the layer is a 'fills' layer, add the corresponding 'borders' layer
    if (layerBaseId.includes('fills')) {
        layerIds.push(layerBaseId.replace('fills', 'borders'));
    }

    layerIds.forEach(layer => {
        if (!map.getLayer(layer)) return;
        const visibility = map.getLayoutProperty(layer, 'visibility');
        map.setLayoutProperty(layer, 'visibility',
            (visibility === 'visible' || visibility === undefined) ? 'none' : 'visible'
        );
    });
}


</script>



</body>